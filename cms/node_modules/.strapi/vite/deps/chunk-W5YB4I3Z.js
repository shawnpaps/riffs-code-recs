import {
  intervalToDuration,
  isPast
} from "./chunk-PGI5Y7U7.js";
import {
  BackButton,
  DescriptionComponentRenderer,
  Table,
  ValidationError,
  create2 as create,
  create3 as create2,
  create4 as create3,
  create5 as create4,
  create6 as create5,
  create7 as create6,
  create8 as create7,
  errorsTrads,
  generateNKeysBetween,
  getYupValidationErrors,
  require_mapValues,
  useForm,
  useTable
} from "./chunk-HH6IMT5T.js";
import {
  Page,
  createContext,
  useAPIErrorHandler,
  useAuth,
  useGuidedTour,
  useNotification,
  useQueryParams,
  useRBAC,
  useStrapiApp,
  useTracking
} from "./chunk-VKH5CSPD.js";
import {
  Box,
  Button,
  Dialog,
  ErrorCode,
  Flex,
  FormatError,
  IconButton,
  IntlMessageFormat,
  LinkButton,
  Loader,
  Menu,
  Modal,
  Radio,
  RawTable,
  SingleSelect,
  SingleSelectOption,
  Status,
  TYPE,
  Tbody,
  Td,
  TooltipImpl,
  Tr,
  Typography,
  VisuallyHidden,
  __assign,
  __extends,
  __rest,
  __spreadArray,
  adminApi,
  combineReducers,
  createSlice,
  invariant,
  isFormatXMLElementFn,
  memoize,
  require_convert,
  require_hoist_non_react_statics_cjs,
  require_lib,
  require_pipe,
  require_placeholder,
  strategies
} from "./chunk-YOH64ARV.js";
import {
  Link,
  NavLink,
  Navigate,
  useLocation,
  useMatch,
  useNavigate,
  useParams
} from "./chunk-BNKKIWCQ.js";
import {
  ForwardRef$1R,
  ForwardRef$1r,
  ForwardRef$2h,
  ForwardRef$3,
  ForwardRef$3$,
  ForwardRef$3L,
  ForwardRef$3Z,
  ForwardRef$3r,
  ForwardRef$4$,
  ForwardRef$4j,
  ForwardRef$4p,
  ForwardRef$4v,
  ForwardRef$4x,
  ForwardRef$j
} from "./chunk-6KUY6VRU.js";
import {
  require_jsx_runtime
} from "./chunk-7UPSCK2M.js";
import {
  dt
} from "./chunk-G3ROERZ2.js";
import {
  require_react
} from "./chunk-KUWPP3IT.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/fp/mapValues.js
var require_mapValues2 = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/fp/mapValues.js"(exports, module) {
    var convert = require_convert();
    var func = convert("mapValues", require_mapValues());
    func.placeholder = require_placeholder();
    module.exports = func;
  }
});

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/useIntl.js
var React3 = __toESM(require_react());

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/injectIntl.js
var React2 = __toESM(require_react());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/utils.js
var React = __toESM(require_react());

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/error.js
var IntlErrorCode;
(function(IntlErrorCode2) {
  IntlErrorCode2["FORMAT_ERROR"] = "FORMAT_ERROR";
  IntlErrorCode2["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
  IntlErrorCode2["INVALID_CONFIG"] = "INVALID_CONFIG";
  IntlErrorCode2["MISSING_DATA"] = "MISSING_DATA";
  IntlErrorCode2["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
})(IntlErrorCode || (IntlErrorCode = {}));
var IntlError = (
  /** @class */
  function(_super) {
    __extends(IntlError2, _super);
    function IntlError2(code, message, exception) {
      var _this = this;
      var err = exception ? exception instanceof Error ? exception : new Error(String(exception)) : void 0;
      _this = _super.call(this, "[@formatjs/intl Error ".concat(code, "] ").concat(message, "\n").concat(err ? "\n".concat(err.message, "\n").concat(err.stack) : "")) || this;
      _this.code = code;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, IntlError2);
      }
      return _this;
    }
    return IntlError2;
  }(Error)
);
var UnsupportedFormatterError = (
  /** @class */
  function(_super) {
    __extends(UnsupportedFormatterError2, _super);
    function UnsupportedFormatterError2(message, exception) {
      return _super.call(this, IntlErrorCode.UNSUPPORTED_FORMATTER, message, exception) || this;
    }
    return UnsupportedFormatterError2;
  }(IntlError)
);
var InvalidConfigError = (
  /** @class */
  function(_super) {
    __extends(InvalidConfigError2, _super);
    function InvalidConfigError2(message, exception) {
      return _super.call(this, IntlErrorCode.INVALID_CONFIG, message, exception) || this;
    }
    return InvalidConfigError2;
  }(IntlError)
);
var MissingDataError = (
  /** @class */
  function(_super) {
    __extends(MissingDataError2, _super);
    function MissingDataError2(message, exception) {
      return _super.call(this, IntlErrorCode.MISSING_DATA, message, exception) || this;
    }
    return MissingDataError2;
  }(IntlError)
);
var IntlFormatError = (
  /** @class */
  function(_super) {
    __extends(IntlFormatError2, _super);
    function IntlFormatError2(message, locale, exception) {
      var _this = _super.call(this, IntlErrorCode.FORMAT_ERROR, "".concat(message, "\nLocale: ").concat(locale, "\n"), exception) || this;
      _this.locale = locale;
      return _this;
    }
    return IntlFormatError2;
  }(IntlError)
);
var MessageFormatError = (
  /** @class */
  function(_super) {
    __extends(MessageFormatError2, _super);
    function MessageFormatError2(message, locale, descriptor, exception) {
      var _this = _super.call(this, "".concat(message, "\nMessageID: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.id, "\nDefault Message: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.defaultMessage, "\nDescription: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.description, "\n"), locale, exception) || this;
      _this.descriptor = descriptor;
      _this.locale = locale;
      return _this;
    }
    return MessageFormatError2;
  }(IntlFormatError)
);
var MissingTranslationError = (
  /** @class */
  function(_super) {
    __extends(MissingTranslationError2, _super);
    function MissingTranslationError2(descriptor, locale) {
      var _this = _super.call(this, IntlErrorCode.MISSING_TRANSLATION, 'Missing message: "'.concat(descriptor.id, '" for locale "').concat(locale, '", using ').concat(descriptor.defaultMessage ? "default message (".concat(typeof descriptor.defaultMessage === "string" ? descriptor.defaultMessage : descriptor.defaultMessage.map(function(e) {
        var _a;
        return (_a = e.value) !== null && _a !== void 0 ? _a : JSON.stringify(e);
      }).join(), ")") : "id", " as fallback.")) || this;
      _this.descriptor = descriptor;
      return _this;
    }
    return MissingTranslationError2;
  }(IntlError)
);

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/utils.js
function filterProps(props, allowlist, defaults) {
  if (defaults === void 0) {
    defaults = {};
  }
  return allowlist.reduce(function(filtered, name) {
    if (name in props) {
      filtered[name] = props[name];
    } else if (name in defaults) {
      filtered[name] = defaults[name];
    }
    return filtered;
  }, {});
}
var defaultErrorHandler = function(error) {
  if (true) {
    console.error(error);
  }
};
var defaultWarnHandler = function(warning) {
  if (true) {
    console.warn(warning);
  }
};
var DEFAULT_INTL_CONFIG = {
  formats: {},
  messages: {},
  timeZone: void 0,
  defaultLocale: "en",
  defaultFormats: {},
  fallbackOnEmptyString: true,
  onError: defaultErrorHandler,
  onWarn: defaultWarnHandler
};
function createIntlCache() {
  return {
    dateTime: {},
    number: {},
    message: {},
    relativeTime: {},
    pluralRules: {},
    list: {},
    displayNames: {}
  };
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createFormatters(cache) {
  if (cache === void 0) {
    cache = createIntlCache();
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  var ListFormat = Intl.ListFormat;
  var DisplayNames = Intl.DisplayNames;
  var getDateTimeFormat = memoize(function() {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.dateTime),
    strategy: strategies.variadic
  });
  var getNumberFormat = memoize(function() {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.number),
    strategy: strategies.variadic
  });
  var getPluralRules = memoize(function() {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.pluralRules),
    strategy: strategies.variadic
  });
  return {
    getDateTimeFormat,
    getNumberFormat,
    getMessageFormat: memoize(function(message, locales, overrideFormats, opts) {
      return new IntlMessageFormat(message, locales, overrideFormats, __assign({ formatters: {
        getNumberFormat,
        getDateTimeFormat,
        getPluralRules
      } }, opts || {}));
    }, {
      cache: createFastMemoizeCache(cache.message),
      strategy: strategies.variadic
    }),
    getRelativeTimeFormat: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.relativeTime),
      strategy: strategies.variadic
    }),
    getPluralRules,
    getListFormat: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (ListFormat.bind.apply(ListFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.list),
      strategy: strategies.variadic
    }),
    getDisplayNames: memoize(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (DisplayNames.bind.apply(DisplayNames, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.displayNames),
      strategy: strategies.variadic
    })
  };
}
function getNamedFormat(formats, type, name, onError) {
  var formatType = formats && formats[type];
  var format;
  if (formatType) {
    format = formatType[name];
  }
  if (format) {
    return format;
  }
  onError(new UnsupportedFormatterError("No ".concat(type, " format named: ").concat(name)));
}

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/message.js
function setTimeZoneInOptions(opts, timeZone) {
  return Object.keys(opts).reduce(function(all, k) {
    all[k] = __assign({ timeZone }, opts[k]);
    return all;
  }, {});
}
function deepMergeOptions(opts1, opts2) {
  var keys = Object.keys(__assign(__assign({}, opts1), opts2));
  return keys.reduce(function(all, k) {
    all[k] = __assign(__assign({}, opts1[k] || {}), opts2[k] || {});
    return all;
  }, {});
}
function deepMergeFormatsAndSetTimeZone(f1, timeZone) {
  if (!timeZone) {
    return f1;
  }
  var mfFormats = IntlMessageFormat.formats;
  return __assign(__assign(__assign({}, mfFormats), f1), { date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)), time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone)) });
}
var formatMessage = function(_a, state, messageDescriptor, values, opts) {
  var locale = _a.locale, formats = _a.formats, messages = _a.messages, defaultLocale = _a.defaultLocale, defaultFormats = _a.defaultFormats, fallbackOnEmptyString = _a.fallbackOnEmptyString, onError = _a.onError, timeZone = _a.timeZone, defaultRichTextElements = _a.defaultRichTextElements;
  if (messageDescriptor === void 0) {
    messageDescriptor = { id: "" };
  }
  var msgId = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
  invariant(!!msgId, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.io/docs/tooling/linter#enforce-id)\nto autofix this issue");
  var id = String(msgId);
  var message = (
    // In case messages is Object.create(null)
    // e.g import('foo.json') from webpack)
    // See https://github.com/formatjs/formatjs/issues/1914
    messages && Object.prototype.hasOwnProperty.call(messages, id) && messages[id]
  );
  if (Array.isArray(message) && message.length === 1 && message[0].type === TYPE.literal) {
    return message[0].value;
  }
  if (!values && message && typeof message === "string" && !defaultRichTextElements) {
    return message.replace(/'\{(.*?)\}'/gi, "{$1}");
  }
  values = __assign(__assign({}, defaultRichTextElements), values || {});
  formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
  defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);
  if (!message) {
    if (fallbackOnEmptyString === false && message === "") {
      return message;
    }
    if (!defaultMessage || locale && locale.toLowerCase() !== defaultLocale.toLowerCase()) {
      onError(new MissingTranslationError(messageDescriptor, locale));
    }
    if (defaultMessage) {
      try {
        var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
        return formatter.format(values);
      } catch (e) {
        onError(new MessageFormatError('Error formatting default message for: "'.concat(id, '", rendering default message verbatim'), locale, messageDescriptor, e));
        return typeof defaultMessage === "string" ? defaultMessage : id;
      }
    }
    return id;
  }
  try {
    var formatter = state.getMessageFormat(message, locale, formats, __assign({ formatters: state }, opts || {}));
    return formatter.format(values);
  } catch (e) {
    onError(new MessageFormatError('Error formatting message: "'.concat(id, '", using ').concat(defaultMessage ? "default message" : "id", " as fallback."), locale, messageDescriptor, e));
  }
  if (defaultMessage) {
    try {
      var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
      return formatter.format(values);
    } catch (e) {
      onError(new MessageFormatError('Error formatting the default message for: "'.concat(id, '", rendering message verbatim'), locale, messageDescriptor, e));
    }
  }
  if (typeof message === "string") {
    return message;
  }
  if (typeof defaultMessage === "string") {
    return defaultMessage;
  }
  return id;
};

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/dateTime.js
var DATE_TIME_FORMAT_OPTIONS = [
  "formatMatcher",
  "timeZone",
  "hour12",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "hourCycle",
  "dateStyle",
  "timeStyle",
  "calendar",
  // 'dayPeriod',
  "numberingSystem",
  "fractionalSecondDigits"
];
function getFormatter(_a, type, getDateTimeFormat, options) {
  var locale = _a.locale, formats = _a.formats, onError = _a.onError, timeZone = _a.timeZone;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = __assign(__assign({}, timeZone && { timeZone }), format && getNamedFormat(formats, type, format, onError));
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
  if (type === "time" && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second && !filteredOptions.timeStyle && !filteredOptions.dateStyle) {
    filteredOptions = __assign(__assign({}, filteredOptions), { hour: "numeric", minute: "numeric" });
  }
  return getDateTimeFormat(locale, filteredOptions);
}
function formatDate(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "date", getDateTimeFormat, options).format(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting date.", config.locale, e));
  }
  return String(date);
}
function formatTime(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "time", getDateTimeFormat, options).format(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting time.", config.locale, e));
  }
  return String(date);
}
function formatDateTimeRange(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var from = _a[0], to = _a[1], _b = _a[2], options = _b === void 0 ? {} : _b;
  var timeZone = config.timeZone, locale = config.locale, onError = config.onError;
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, timeZone ? { timeZone } : {});
  try {
    return getDateTimeFormat(locale, filteredOptions).formatRange(from, to);
  } catch (e) {
    onError(new IntlFormatError("Error formatting date time range.", config.locale, e));
  }
  return String(from);
}
function formatDateToParts(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "date", getDateTimeFormat, options).formatToParts(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting date.", config.locale, e));
  }
  return [];
}
function formatTimeToParts(config, getDateTimeFormat) {
  var _a = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a[_i - 2] = arguments[_i];
  }
  var value = _a[0], _b = _a[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter(config, "time", getDateTimeFormat, options).formatToParts(date);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting time.", config.locale, e));
  }
  return [];
}

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/displayName.js
var DISPLAY_NAMES_OPTONS = [
  "style",
  "type",
  "fallback",
  "languageDisplay"
];
function formatDisplayName(_a, getDisplayNames, value, options) {
  var locale = _a.locale, onError = _a.onError;
  var DisplayNames = Intl.DisplayNames;
  if (!DisplayNames) {
    onError(new FormatError('Intl.DisplayNames is not available in this environment.\nTry polyfilling it using "@formatjs/intl-displaynames"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
  try {
    return getDisplayNames(locale, filteredOptions).of(value);
  } catch (e) {
    onError(new IntlFormatError("Error formatting display name.", locale, e));
  }
}

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/list.js
var LIST_FORMAT_OPTIONS = [
  "type",
  "style"
];
var now = Date.now();
function generateToken(i) {
  return "".concat(now, "_").concat(i, "_").concat(now);
}
function formatList(opts, getListFormat, values, options) {
  if (options === void 0) {
    options = {};
  }
  var results = formatListToParts(opts, getListFormat, values, options).reduce(function(all, el) {
    var val = el.value;
    if (typeof val !== "string") {
      all.push(val);
    } else if (typeof all[all.length - 1] === "string") {
      all[all.length - 1] += val;
    } else {
      all.push(val);
    }
    return all;
  }, []);
  return results.length === 1 ? results[0] : results.length === 0 ? "" : results;
}
function formatListToParts(_a, getListFormat, values, options) {
  var locale = _a.locale, onError = _a.onError;
  if (options === void 0) {
    options = {};
  }
  var ListFormat = Intl.ListFormat;
  if (!ListFormat) {
    onError(new FormatError('Intl.ListFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-listformat"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
  try {
    var richValues_1 = {};
    var serializedValues = values.map(function(v, i) {
      if (typeof v === "object") {
        var id = generateToken(i);
        richValues_1[id] = v;
        return id;
      }
      return String(v);
    });
    return getListFormat(locale, filteredOptions).formatToParts(serializedValues).map(function(part) {
      return part.type === "literal" ? part : __assign(__assign({}, part), { value: richValues_1[part.value] || part.value });
    });
  } catch (e) {
    onError(new IntlFormatError("Error formatting list.", locale, e));
  }
  return values;
}

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/plural.js
var PLURAL_FORMAT_OPTIONS = ["type"];
function formatPlural(_a, getPluralRules, value, options) {
  var locale = _a.locale, onError = _a.onError;
  if (options === void 0) {
    options = {};
  }
  if (!Intl.PluralRules) {
    onError(new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
  try {
    return getPluralRules(locale, filteredOptions).select(value);
  } catch (e) {
    onError(new IntlFormatError("Error formatting plural.", locale, e));
  }
  return "other";
}

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/relativeTime.js
var RELATIVE_TIME_FORMAT_OPTIONS = ["numeric", "style"];
function getFormatter2(_a, getRelativeTimeFormat, options) {
  var locale = _a.locale, formats = _a.formats, onError = _a.onError;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = !!format && getNamedFormat(formats, "relative", format, onError) || {};
  var filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults);
  return getRelativeTimeFormat(locale, filteredOptions);
}
function formatRelativeTime(config, getRelativeTimeFormat, value, unit, options) {
  if (options === void 0) {
    options = {};
  }
  if (!unit) {
    unit = "second";
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  if (!RelativeTimeFormat) {
    config.onError(new FormatError('Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-relativetimeformat"\n', ErrorCode.MISSING_INTL_API));
  }
  try {
    return getFormatter2(config, getRelativeTimeFormat, options).format(value, unit);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting relative time.", config.locale, e));
  }
  return String(value);
}

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/number.js
var NUMBER_FORMAT_OPTIONS = [
  "style",
  "currency",
  "unit",
  "unitDisplay",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  // ES2020 NumberFormat
  "compactDisplay",
  "currencyDisplay",
  "currencySign",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "numberingSystem",
  // ES2023 NumberFormat
  "trailingZeroDisplay",
  "roundingPriority",
  "roundingIncrement",
  "roundingMode"
];
function getFormatter3(_a, getNumberFormat, options) {
  var locale = _a.locale, formats = _a.formats, onError = _a.onError;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = format && getNamedFormat(formats, "number", format, onError) || {};
  var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
  return getNumberFormat(locale, filteredOptions);
}
function formatNumber(config, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter3(config, getNumberFormat, options).format(value);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting number.", config.locale, e));
  }
  return String(value);
}
function formatNumberToParts(config, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter3(config, getNumberFormat, options).formatToParts(value);
  } catch (e) {
    config.onError(new IntlFormatError("Error formatting number.", config.locale, e));
  }
  return [];
}

// node_modules/.pnpm/@formatjs+intl@2.10.0_typescript@5.7.3/node_modules/@formatjs/intl/lib/src/create-intl.js
function messagesContainString(messages) {
  var firstMessage = messages ? messages[Object.keys(messages)[0]] : void 0;
  return typeof firstMessage === "string";
}
function verifyConfigMessages(config) {
  if (config.onWarn && config.defaultRichTextElements && messagesContainString(config.messages || {})) {
    config.onWarn('[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. \nPlease consider using "@formatjs/cli" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution');
  }
}
function createIntl(config, cache) {
  var formatters = createFormatters(cache);
  var resolvedConfig = __assign(__assign({}, DEFAULT_INTL_CONFIG), config);
  var locale = resolvedConfig.locale, defaultLocale = resolvedConfig.defaultLocale, onError = resolvedConfig.onError;
  if (!locale) {
    if (onError) {
      onError(new InvalidConfigError('"locale" was not configured, using "'.concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details')));
    }
    resolvedConfig.locale = resolvedConfig.defaultLocale || "en";
  } else if (!Intl.NumberFormat.supportedLocalesOf(locale).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale, '" in Intl.NumberFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  } else if (!Intl.DateTimeFormat.supportedLocalesOf(locale).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale, '" in Intl.DateTimeFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  }
  verifyConfigMessages(resolvedConfig);
  return __assign(__assign({}, resolvedConfig), {
    formatters,
    formatNumber: formatNumber.bind(null, resolvedConfig, formatters.getNumberFormat),
    formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters.getNumberFormat),
    formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters.getRelativeTimeFormat),
    formatDate: formatDate.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatTime: formatTime.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatDateTimeRange: formatDateTimeRange.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatPlural: formatPlural.bind(null, resolvedConfig, formatters.getPluralRules),
    // @ts-expect-error TODO: will get to this later
    formatMessage: formatMessage.bind(null, resolvedConfig, formatters),
    // @ts-expect-error TODO: will get to this later
    $t: formatMessage.bind(null, resolvedConfig, formatters),
    formatList: formatList.bind(null, resolvedConfig, formatters.getListFormat),
    formatListToParts: formatListToParts.bind(null, resolvedConfig, formatters.getListFormat),
    formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters.getDisplayNames)
  });
}

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/utils.js
function invariantIntlContext(intl) {
  invariant(intl, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
var DEFAULT_INTL_CONFIG2 = __assign(__assign({}, DEFAULT_INTL_CONFIG), { textComponent: React.Fragment });
function assignUniqueKeysToParts(formatXMLElementFn) {
  return function(parts) {
    return formatXMLElementFn(React.Children.toArray(parts));
  };
}
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i = 0; i < len; i++) {
    var key = aKeys[i];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/injectIntl.js
var IntlContext = typeof window !== "undefined" && !window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = React2.createContext(null)) : React2.createContext(null);
var IntlConsumer = IntlContext.Consumer;
var IntlProvider = IntlContext.Provider;
var Provider = IntlProvider;
var Context = IntlContext;

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/useIntl.js
function useIntl() {
  var intl = React3.useContext(Context);
  invariantIntlContext(intl);
  return intl;
}

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/createFormattedComponent.js
var React4 = __toESM(require_react());
var DisplayName;
(function(DisplayName2) {
  DisplayName2["formatDate"] = "FormattedDate";
  DisplayName2["formatTime"] = "FormattedTime";
  DisplayName2["formatNumber"] = "FormattedNumber";
  DisplayName2["formatList"] = "FormattedList";
  DisplayName2["formatDisplayName"] = "FormattedDisplayName";
})(DisplayName || (DisplayName = {}));
var DisplayNameParts;
(function(DisplayNameParts2) {
  DisplayNameParts2["formatDate"] = "FormattedDateParts";
  DisplayNameParts2["formatTime"] = "FormattedTimeParts";
  DisplayNameParts2["formatNumber"] = "FormattedNumberParts";
  DisplayNameParts2["formatList"] = "FormattedListParts";
})(DisplayNameParts || (DisplayNameParts = {}));
var FormattedNumberParts = function(props) {
  var intl = useIntl();
  var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
  return children(intl.formatNumberToParts(value, formatProps));
};
FormattedNumberParts.displayName = "FormattedNumberParts";
FormattedNumberParts.displayName = "FormattedNumberParts";
function createFormattedDateTimePartsComponent(name) {
  var ComponentParts = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
    var date = typeof value === "string" ? new Date(value || 0) : value;
    var formattedParts = name === "formatDate" ? intl.formatDateToParts(date, formatProps) : intl.formatTimeToParts(date, formatProps);
    return children(formattedParts);
  };
  ComponentParts.displayName = DisplayNameParts[name];
  return ComponentParts;
}
function createFormattedComponent(name) {
  var Component = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(
      props,
      ["value", "children"]
    );
    var formattedValue = intl[name](value, formatProps);
    if (typeof children === "function") {
      return children(formattedValue);
    }
    var Text = intl.textComponent || React4.Fragment;
    return React4.createElement(Text, null, formattedValue);
  };
  Component.displayName = DisplayName[name];
  return Component;
}

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/provider.js
var React6 = __toESM(require_react());

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/createIntl.js
var React5 = __toESM(require_react());
function assignUniqueKeysToFormatXMLElementFnArgument(values) {
  if (!values) {
    return values;
  }
  return Object.keys(values).reduce(function(acc, k) {
    var v = values[k];
    acc[k] = isFormatXMLElementFn(v) ? assignUniqueKeysToParts(v) : v;
    return acc;
  }, {});
}
var formatMessage2 = function(config, formatters, descriptor, rawValues) {
  var rest = [];
  for (var _i = 4; _i < arguments.length; _i++) {
    rest[_i - 4] = arguments[_i];
  }
  var values = assignUniqueKeysToFormatXMLElementFnArgument(rawValues);
  var chunks = formatMessage.apply(void 0, __spreadArray([
    config,
    formatters,
    descriptor,
    values
  ], rest, false));
  if (Array.isArray(chunks)) {
    return React5.Children.toArray(chunks);
  }
  return chunks;
};
var createIntl2 = function(_a, cache) {
  var rawDefaultRichTextElements = _a.defaultRichTextElements, config = __rest(_a, ["defaultRichTextElements"]);
  var defaultRichTextElements = assignUniqueKeysToFormatXMLElementFnArgument(rawDefaultRichTextElements);
  var coreIntl = createIntl(__assign(__assign(__assign({}, DEFAULT_INTL_CONFIG2), config), { defaultRichTextElements }), cache);
  var resolvedConfig = {
    locale: coreIntl.locale,
    timeZone: coreIntl.timeZone,
    fallbackOnEmptyString: coreIntl.fallbackOnEmptyString,
    formats: coreIntl.formats,
    defaultLocale: coreIntl.defaultLocale,
    defaultFormats: coreIntl.defaultFormats,
    messages: coreIntl.messages,
    onError: coreIntl.onError,
    defaultRichTextElements
  };
  return __assign(__assign({}, coreIntl), {
    formatMessage: formatMessage2.bind(
      null,
      resolvedConfig,
      // @ts-expect-error fix this
      coreIntl.formatters
    ),
    // @ts-expect-error fix this
    $t: formatMessage2.bind(null, resolvedConfig, coreIntl.formatters)
  });
};

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/provider.js
function processIntlConfig(config) {
  return {
    locale: config.locale,
    timeZone: config.timeZone,
    fallbackOnEmptyString: config.fallbackOnEmptyString,
    formats: config.formats,
    textComponent: config.textComponent,
    messages: config.messages,
    defaultLocale: config.defaultLocale,
    defaultFormats: config.defaultFormats,
    onError: config.onError,
    onWarn: config.onWarn,
    wrapRichTextChunksInFragment: config.wrapRichTextChunksInFragment,
    defaultRichTextElements: config.defaultRichTextElements
  };
}
var IntlProvider2 = (
  /** @class */
  function(_super) {
    __extends(IntlProvider3, _super);
    function IntlProvider3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = createIntlCache();
      _this.state = {
        cache: _this.cache,
        intl: createIntl2(processIntlConfig(_this.props), _this.cache),
        prevConfig: processIntlConfig(_this.props)
      };
      return _this;
    }
    IntlProvider3.getDerivedStateFromProps = function(props, _a) {
      var prevConfig = _a.prevConfig, cache = _a.cache;
      var config = processIntlConfig(props);
      if (!shallowEqual(prevConfig, config)) {
        return {
          intl: createIntl2(config, cache),
          prevConfig: config
        };
      }
      return null;
    };
    IntlProvider3.prototype.render = function() {
      invariantIntlContext(this.state.intl);
      return React6.createElement(Provider, { value: this.state.intl }, this.props.children);
    };
    IntlProvider3.displayName = "IntlProvider";
    IntlProvider3.defaultProps = DEFAULT_INTL_CONFIG2;
    return IntlProvider3;
  }(React6.PureComponent)
);

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/relative.js
var React7 = __toESM(require_react());
var MINUTE = 60;
var HOUR = 60 * 60;
var DAY = 60 * 60 * 24;
function selectUnit(seconds) {
  var absValue = Math.abs(seconds);
  if (absValue < MINUTE) {
    return "second";
  }
  if (absValue < HOUR) {
    return "minute";
  }
  if (absValue < DAY) {
    return "hour";
  }
  return "day";
}
function getDurationInSeconds(unit) {
  switch (unit) {
    case "second":
      return 1;
    case "minute":
      return MINUTE;
    case "hour":
      return HOUR;
    default:
      return DAY;
  }
}
function valueToSeconds(value, unit) {
  if (!value) {
    return 0;
  }
  switch (unit) {
    case "second":
      return value;
    case "minute":
      return value * MINUTE;
    default:
      return value * HOUR;
  }
}
var INCREMENTABLE_UNITS = [
  "second",
  "minute",
  "hour"
];
function canIncrement(unit) {
  if (unit === void 0) {
    unit = "second";
  }
  return INCREMENTABLE_UNITS.indexOf(unit) > -1;
}
var SimpleFormattedRelativeTime = function(props) {
  var _a = useIntl(), formatRelativeTime2 = _a.formatRelativeTime, Text = _a.textComponent;
  var children = props.children, value = props.value, unit = props.unit, otherProps = __rest(props, ["children", "value", "unit"]);
  var formattedRelativeTime = formatRelativeTime2(value || 0, unit, otherProps);
  if (typeof children === "function") {
    return children(formattedRelativeTime);
  }
  if (Text) {
    return React7.createElement(Text, null, formattedRelativeTime);
  }
  return React7.createElement(React7.Fragment, null, formattedRelativeTime);
};
var FormattedRelativeTime = function(_a) {
  var _b = _a.value, value = _b === void 0 ? 0 : _b, _c = _a.unit, unit = _c === void 0 ? "second" : _c, updateIntervalInSeconds = _a.updateIntervalInSeconds, otherProps = __rest(_a, ["value", "unit", "updateIntervalInSeconds"]);
  invariant(!updateIntervalInSeconds || !!(updateIntervalInSeconds && canIncrement(unit)), "Cannot schedule update with unit longer than hour");
  var _d = React7.useState(), prevUnit = _d[0], setPrevUnit = _d[1];
  var _e = React7.useState(0), prevValue = _e[0], setPrevValue = _e[1];
  var _f = React7.useState(0), currentValueInSeconds = _f[0], setCurrentValueInSeconds = _f[1];
  var updateTimer;
  if (unit !== prevUnit || value !== prevValue) {
    setPrevValue(value || 0);
    setPrevUnit(unit);
    setCurrentValueInSeconds(canIncrement(unit) ? valueToSeconds(value, unit) : 0);
  }
  React7.useEffect(function() {
    function clearUpdateTimer() {
      clearTimeout(updateTimer);
    }
    clearUpdateTimer();
    if (!updateIntervalInSeconds || !canIncrement(unit)) {
      return clearUpdateTimer;
    }
    var nextValueInSeconds = currentValueInSeconds - updateIntervalInSeconds;
    var nextUnit = selectUnit(nextValueInSeconds);
    if (nextUnit === "day") {
      return clearUpdateTimer;
    }
    var unitDuration2 = getDurationInSeconds(nextUnit);
    var remainder = nextValueInSeconds % unitDuration2;
    var prevInterestingValueInSeconds = nextValueInSeconds - remainder;
    var nextInterestingValueInSeconds = prevInterestingValueInSeconds >= currentValueInSeconds ? prevInterestingValueInSeconds - unitDuration2 : prevInterestingValueInSeconds;
    var delayInSeconds = Math.abs(nextInterestingValueInSeconds - currentValueInSeconds);
    if (currentValueInSeconds !== nextInterestingValueInSeconds) {
      updateTimer = setTimeout(function() {
        return setCurrentValueInSeconds(nextInterestingValueInSeconds);
      }, delayInSeconds * 1e3);
    }
    return clearUpdateTimer;
  }, [currentValueInSeconds, updateIntervalInSeconds, unit]);
  var currentValue = value || 0;
  var currentUnit = unit;
  if (canIncrement(unit) && typeof currentValueInSeconds === "number" && updateIntervalInSeconds) {
    currentUnit = selectUnit(currentValueInSeconds);
    var unitDuration = getDurationInSeconds(currentUnit);
    currentValue = Math.round(currentValueInSeconds / unitDuration);
  }
  return React7.createElement(SimpleFormattedRelativeTime, __assign({ value: currentValue, unit: currentUnit }, otherProps));
};
FormattedRelativeTime.displayName = "FormattedRelativeTime";

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/plural.js
var React8 = __toESM(require_react());
var FormattedPlural = function(props) {
  var _a = useIntl(), formatPlural2 = _a.formatPlural, Text = _a.textComponent;
  var value = props.value, other = props.other, children = props.children;
  var pluralCategory = formatPlural2(value, props);
  var formattedPlural = props[pluralCategory] || other;
  if (typeof children === "function") {
    return children(formattedPlural);
  }
  if (Text) {
    return React8.createElement(Text, null, formattedPlural);
  }
  return formattedPlural;
};
FormattedPlural.displayName = "FormattedPlural";

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/message.js
var React9 = __toESM(require_react());
function areEqual(prevProps, nextProps) {
  var values = prevProps.values, otherProps = __rest(prevProps, ["values"]);
  var nextValues = nextProps.values, nextOtherProps = __rest(nextProps, ["values"]);
  return shallowEqual(nextValues, values) && shallowEqual(otherProps, nextOtherProps);
}
function FormattedMessage(props) {
  var intl = useIntl();
  var formatMessage3 = intl.formatMessage, _a = intl.textComponent, Text = _a === void 0 ? React9.Fragment : _a;
  var id = props.id, description = props.description, defaultMessage = props.defaultMessage, values = props.values, children = props.children, _b = props.tagName, Component = _b === void 0 ? Text : _b, ignoreTag = props.ignoreTag;
  var descriptor = { id, description, defaultMessage };
  var nodes = formatMessage3(descriptor, values, {
    ignoreTag
  });
  if (typeof children === "function") {
    return children(Array.isArray(nodes) ? nodes : [nodes]);
  }
  if (Component) {
    return React9.createElement(Component, null, React9.Children.toArray(nodes));
  }
  return React9.createElement(React9.Fragment, null, nodes);
}
FormattedMessage.displayName = "FormattedMessage";
var MemoizedFormattedMessage = React9.memo(FormattedMessage, areEqual);
MemoizedFormattedMessage.displayName = "MemoizedFormattedMessage";

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/src/components/dateTimeRange.js
var React10 = __toESM(require_react());
var FormattedDateTimeRange = function(props) {
  var intl = useIntl();
  var from = props.from, to = props.to, children = props.children, formatProps = __rest(props, ["from", "to", "children"]);
  var formattedValue = intl.formatDateTimeRange(from, to, formatProps);
  if (typeof children === "function") {
    return children(formattedValue);
  }
  var Text = intl.textComponent || React10.Fragment;
  return React10.createElement(Text, null, formattedValue);
};
FormattedDateTimeRange.displayName = "FormattedDateTimeRange";

// node_modules/.pnpm/react-intl@6.6.2_react@18.3.1_typescript@5.7.3/node_modules/react-intl/lib/index.js
var FormattedDate = createFormattedComponent("formatDate");
var FormattedTime = createFormattedComponent("formatTime");
var FormattedNumber = createFormattedComponent("formatNumber");
var FormattedList = createFormattedComponent("formatList");
var FormattedDisplayName = createFormattedComponent("formatDisplayName");
var FormattedDateParts = createFormattedDateTimePartsComponent("formatDate");
var FormattedTimeParts = createFormattedDateTimePartsComponent("formatTime");

// node_modules/.pnpm/@strapi+content-manager@5.9.0_u3excvqxyaoygr3f5wfbvza2uq/node_modules/@strapi/content-manager/dist/_chunks/index-ZKrsjv-2.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React11 = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_mapValues = __toESM(require_mapValues2(), 1);
var import_pipe = __toESM(require_pipe(), 1);
var import_qs = __toESM(require_lib(), 1);
var __variableDynamicImportRuntimeHelper = (glob, path, segs) => {
  const v = glob[path];
  if (v) {
    return typeof v === "function" ? v() : Promise.resolve(v);
  }
  return new Promise((_, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
      reject.bind(
        null,
        new Error(
          "Unknown variable dynamic import: " + path + (path.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : "")
        )
      )
    );
  });
};
var PLUGIN_ID = "content-manager";
var PERMISSIONS = [
  "plugin::content-manager.explorer.create",
  "plugin::content-manager.explorer.read",
  "plugin::content-manager.explorer.update",
  "plugin::content-manager.explorer.delete",
  "plugin::content-manager.explorer.publish"
];
var INJECTION_ZONES = {
  editView: { informations: [], "right-links": [] },
  listView: {
    actions: [],
    deleteModalAdditionalInfos: [],
    publishModalAdditionalInfos: [],
    unpublishModalAdditionalInfos: []
  }
};
var InjectionZone = ({ area, ...props }) => {
  const components = useInjectionZone(area);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: components.map((component) => (0, import_jsx_runtime.jsx)(component.Component, { ...props }, component.name)) });
};
var useInjectionZone = (area) => {
  const getPlugin = useStrapiApp("useInjectionZone", (state) => state.getPlugin);
  const contentManagerPlugin = getPlugin(PLUGIN_ID);
  const [page, position] = area.split(".");
  return contentManagerPlugin.getInjectedComponents(page, position);
};
var ID = "id";
var CREATED_BY_ATTRIBUTE_NAME = "createdBy";
var UPDATED_BY_ATTRIBUTE_NAME = "updatedBy";
var CREATOR_FIELDS = [CREATED_BY_ATTRIBUTE_NAME, UPDATED_BY_ATTRIBUTE_NAME];
var PUBLISHED_BY_ATTRIBUTE_NAME = "publishedBy";
var CREATED_AT_ATTRIBUTE_NAME = "createdAt";
var UPDATED_AT_ATTRIBUTE_NAME = "updatedAt";
var PUBLISHED_AT_ATTRIBUTE_NAME = "publishedAt";
var DOCUMENT_META_FIELDS = [
  ID,
  ...CREATOR_FIELDS,
  PUBLISHED_BY_ATTRIBUTE_NAME,
  CREATED_AT_ATTRIBUTE_NAME,
  UPDATED_AT_ATTRIBUTE_NAME,
  PUBLISHED_AT_ATTRIBUTE_NAME
];
var ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD = [
  "dynamiczone",
  "json",
  "text",
  "relation",
  "component",
  "boolean",
  "media",
  "password",
  "richtext",
  "timestamp",
  "blocks"
];
var SINGLE_TYPES = "single-types";
var COLLECTION_TYPES = "collection-types";
var [DocumentRBACProvider, useDocumentRBAC] = createContext(
  "DocumentRBAC",
  {
    canCreate: false,
    canCreateFields: [],
    canDelete: false,
    canPublish: false,
    canRead: false,
    canReadFields: [],
    canUpdate: false,
    canUpdateFields: [],
    canUserAction: () => false,
    isLoading: false
  }
);
var DocumentRBAC = ({ children, permissions }) => {
  const { slug } = useParams();
  if (!slug) {
    throw new Error("Cannot find the slug param in the URL");
  }
  const [{ rawQuery }] = useQueryParams();
  const userPermissions = useAuth("DocumentRBAC", (state) => state.permissions);
  const contentTypePermissions = React11.useMemo(() => {
    const contentTypePermissions2 = userPermissions.filter(
      (permission) => permission.subject === slug
    );
    return contentTypePermissions2.reduce((acc, permission) => {
      const [action] = permission.action.split(".").slice(-1);
      return { ...acc, [action]: [permission] };
    }, {});
  }, [slug, userPermissions]);
  const { isLoading, allowedActions } = useRBAC(
    contentTypePermissions,
    permissions ?? void 0,
    // TODO: useRBAC context should be typed and built differently
    // We are passing raw query as context to the hook so that it can
    // rely on the locale provided from DocumentRBAC for its permission calculations.
    rawQuery
  );
  const canCreateFields = !isLoading && allowedActions.canCreate ? extractAndDedupeFields(contentTypePermissions.create) : [];
  const canReadFields = !isLoading && allowedActions.canRead ? extractAndDedupeFields(contentTypePermissions.read) : [];
  const canUpdateFields = !isLoading && allowedActions.canUpdate ? extractAndDedupeFields(contentTypePermissions.update) : [];
  const canUserAction = React11.useCallback(
    (fieldName, fieldsUserCanAction, fieldType) => {
      const name = removeNumericalStrings(fieldName.split("."));
      const componentFieldNames = fieldsUserCanAction.filter((field) => field.split(".").length > 1);
      if (fieldType === "component") {
        return componentFieldNames.some((field) => {
          return field.includes(name.join("."));
        });
      }
      if (name.length > 1) {
        return componentFieldNames.includes(name.join("."));
      }
      return fieldsUserCanAction.includes(fieldName);
    },
    []
  );
  if (isLoading) {
    return (0, import_jsx_runtime.jsx)(Page.Loading, {});
  }
  return (0, import_jsx_runtime.jsx)(
    DocumentRBACProvider,
    {
      isLoading,
      canCreateFields,
      canReadFields,
      canUpdateFields,
      canUserAction,
      ...allowedActions,
      children
    }
  );
};
var extractAndDedupeFields = (permissions = []) => permissions.flatMap((permission) => {
  var _a;
  return (_a = permission.properties) == null ? void 0 : _a.fields;
}).filter(
  (field, index2, arr) => arr.indexOf(field) === index2 && typeof field === "string"
);
var removeNumericalStrings = (arr) => arr.filter((item) => isNaN(Number(item)));
var BLOCK_LIST_ATTRIBUTE_KEYS = ["__component", "__temp_key__"];
var traverseData = (predicate, transform) => (schema, components = {}) => (data = {}) => {
  const traverse = (datum, attributes) => {
    return Object.entries(datum).reduce((acc, [key, value]) => {
      var _a;
      const attribute = attributes[key];
      if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === void 0) {
        acc[key] = value;
        return acc;
      }
      if (attribute.type === "component") {
        if (attribute.repeatable) {
          const componentValue = predicate(attribute, value) ? transform(value, attribute) : value;
          acc[key] = componentValue.map(
            (componentData) => {
              var _a2;
              return traverse(componentData, ((_a2 = components[attribute.component]) == null ? void 0 : _a2.attributes) ?? {});
            }
          );
        } else {
          const componentValue = predicate(attribute, value) ? transform(value, attribute) : value;
          acc[key] = traverse(componentValue, ((_a = components[attribute.component]) == null ? void 0 : _a.attributes) ?? {});
        }
      } else if (attribute.type === "dynamiczone") {
        const dynamicZoneValue = predicate(attribute, value) ? transform(value, attribute) : value;
        acc[key] = dynamicZoneValue.map(
          (componentData) => {
            var _a2;
            return traverse(componentData, ((_a2 = components[componentData.__component]) == null ? void 0 : _a2.attributes) ?? {});
          }
        );
      } else if (predicate(attribute, value)) {
        acc[key] = transform(value, attribute);
      } else {
        acc[key] = value;
      }
      return acc;
    }, {});
  };
  return traverse(data, schema.attributes);
};
var removeProhibitedFields = (prohibitedFields) => traverseData(
  (attribute) => prohibitedFields.includes(attribute.type),
  () => ""
);
var prepareRelations = traverseData(
  (attribute) => attribute.type === "relation",
  () => ({
    connect: [],
    disconnect: []
  })
);
var prepareTempKeys = traverseData(
  (attribute) => attribute.type === "component" && attribute.repeatable || attribute.type === "dynamiczone",
  (data) => {
    if (Array.isArray(data) && data.length > 0) {
      const keys = generateNKeysBetween(void 0, void 0, data.length);
      return data.map((datum, index2) => ({
        ...datum,
        __temp_key__: keys[index2]
      }));
    }
    return data;
  }
);
var removeFieldsThatDontExistOnSchema = (schema) => (data) => {
  const schemaKeys = Object.keys(schema.attributes);
  const dataKeys = Object.keys(data);
  const keysToRemove = dataKeys.filter((key) => !schemaKeys.includes(key));
  const revisedData = [...keysToRemove, ...DOCUMENT_META_FIELDS].reduce((acc, key) => {
    delete acc[key];
    return acc;
  }, structuredClone(data));
  return revisedData;
};
var removeNullValues = (data) => {
  return Object.entries(data).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};
var transformDocument = (schema, components = {}) => (document) => {
  const transformations = (0, import_pipe.default)(
    removeFieldsThatDontExistOnSchema(schema),
    removeProhibitedFields(["password"])(schema, components),
    removeNullValues,
    prepareRelations(schema, components),
    prepareTempKeys(schema, components)
  );
  return transformations(document);
};
var createDefaultForm = (contentType, components = {}) => {
  const traverseSchema = (attributes) => {
    return Object.entries(attributes).reduce((acc, [key, attribute]) => {
      if ("default" in attribute) {
        acc[key] = attribute.default;
      } else if (attribute.type === "component" && attribute.required) {
        const defaultComponentForm = traverseSchema(components[attribute.component].attributes);
        if (attribute.repeatable) {
          acc[key] = attribute.min ? [...Array(attribute.min).fill(defaultComponentForm)] : [];
        } else {
          acc[key] = defaultComponentForm;
        }
      } else if (attribute.type === "dynamiczone" && attribute.required) {
        acc[key] = [];
      }
      return acc;
    }, {});
  };
  return traverseSchema(contentType.attributes);
};
var contentManagerApi = adminApi.enhanceEndpoints({
  addTagTypes: [
    "ComponentConfiguration",
    "ContentTypesConfiguration",
    "ContentTypeSettings",
    "Document",
    "InitialData",
    "HistoryVersion",
    "Relations",
    "UidAvailability",
    "RecentDocumentList"
  ]
});
var documentApi = contentManagerApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    autoCloneDocument: builder.mutation({
      query: ({ model, sourceId, query }) => ({
        url: `/content-manager/collection-types/${model}/auto-clone/${sourceId}`,
        method: "POST",
        config: {
          params: query
        }
      }),
      invalidatesTags: (_result, error, { model }) => {
        if (error) {
          return [];
        }
        return [{ type: "Document", id: `${model}_LIST` }, "RecentDocumentList"];
      }
    }),
    cloneDocument: builder.mutation({
      query: ({ model, sourceId, data, params }) => ({
        url: `/content-manager/collection-types/${model}/clone/${sourceId}`,
        method: "POST",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { model }) => [
        { type: "Document", id: `${model}_LIST` },
        { type: "UidAvailability", id: model },
        "RecentDocumentList"
      ]
    }),
    /**
     * Creates a new collection-type document. This should ONLY be used for collection-types.
     * single-types should always be using `updateDocument` since they always exist.
     */
    createDocument: builder.mutation({
      query: ({ model, data, params }) => ({
        url: `/content-manager/collection-types/${model}`,
        method: "POST",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (result, _error, { model }) => [
        { type: "Document", id: `${model}_LIST` },
        "Relations",
        { type: "UidAvailability", id: model },
        "RecentDocumentList"
      ],
      transformResponse: (response, meta, arg) => {
        if (!("data" in response) && arg.model === "plugin::users-permissions.user") {
          return {
            data: response,
            meta: {
              availableStatus: [],
              availableLocales: []
            }
          };
        }
        return response;
      }
    }),
    deleteDocument: builder.mutation({
      query: ({ collectionType, model, documentId, params }) => ({
        url: `/content-manager/${collectionType}/${model}${collectionType !== SINGLE_TYPES && documentId ? `/${documentId}` : ""}`,
        method: "DELETE",
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model }) => [
        { type: "Document", id: collectionType !== SINGLE_TYPES ? `${model}_LIST` : model },
        "RecentDocumentList"
      ]
    }),
    deleteManyDocuments: builder.mutation({
      query: ({ model, params, ...body }) => ({
        url: `/content-manager/collection-types/${model}/actions/bulkDelete`,
        method: "POST",
        data: body,
        config: {
          params
        }
      }),
      invalidatesTags: (_res, _error, { model }) => [
        { type: "Document", id: `${model}_LIST` },
        "RecentDocumentList"
      ]
    }),
    discardDocument: builder.mutation({
      query: ({ collectionType, model, documentId, params }) => ({
        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/discard` : `/content-manager/${collectionType}/${model}/actions/discard`,
        method: "POST",
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {
        return [
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
          },
          { type: "Document", id: `${model}_LIST` },
          "Relations",
          { type: "UidAvailability", id: model },
          "RecentDocumentList"
        ];
      }
    }),
    /**
     * Gets all documents of a collection type or single type.
     * By passing different params you can get different results e.g. only published documents or 'es' documents.
     */
    getAllDocuments: builder.query({
      query: ({ model, params }) => ({
        url: `/content-manager/collection-types/${model}`,
        method: "GET",
        config: {
          params: (0, import_qs.stringify)(params, { encode: true })
        }
      }),
      providesTags: (result, _error, arg) => {
        return [
          { type: "Document", id: `ALL_LIST` },
          { type: "Document", id: `${arg.model}_LIST` },
          ...(result == null ? void 0 : result.results.map(({ documentId }) => ({
            type: "Document",
            id: `${arg.model}_${documentId}`
          }))) ?? []
        ];
      }
    }),
    getDraftRelationCount: builder.query({
      query: ({ collectionType, model, documentId, params }) => ({
        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/countDraftRelations` : `/content-manager/${collectionType}/${model}/actions/countDraftRelations`,
        method: "GET",
        config: {
          params
        }
      })
    }),
    getDocument: builder.query({
      // @ts-expect-error  TODO: fix ts error where data unknown doesn't work with response via an assertion?
      queryFn: async ({ collectionType, model, documentId, params }, _api, _extraOpts, baseQuery) => {
        const res = await baseQuery({
          url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ""}`,
          method: "GET",
          config: {
            params
          }
        });
        if (res.error && res.error.name === "NotFoundError" && collectionType === SINGLE_TYPES) {
          return { data: { document: void 0 }, error: void 0 };
        }
        return res;
      },
      providesTags: (result, _error, { collectionType, model, documentId }) => {
        return [
          // we prefer the result's id because we don't fetch single-types with an ID.
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${result && "documentId" in result ? result.documentId : documentId}` : model
          },
          // Make it easy to invalidate all individual documents queries for a model
          {
            type: "Document",
            id: `${model}_ALL_ITEMS`
          }
        ];
      }
    }),
    getManyDraftRelationCount: builder.query({
      query: ({ model, ...params }) => ({
        url: `/content-manager/collection-types/${model}/actions/countManyEntriesDraftRelations`,
        method: "GET",
        config: {
          params
        }
      }),
      transformResponse: (response) => response.data
    }),
    /**
     * This endpoint will either create or update documents at the same time as publishing.
     */
    publishDocument: builder.mutation({
      query: ({ collectionType, model, documentId, params, data }) => ({
        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/publish` : `/content-manager/${collectionType}/${model}/actions/publish`,
        method: "POST",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {
        return [
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
          },
          { type: "Document", id: `${model}_LIST` },
          "Relations",
          "RecentDocumentList"
        ];
      }
    }),
    publishManyDocuments: builder.mutation({
      query: ({ model, params, ...body }) => ({
        url: `/content-manager/collection-types/${model}/actions/bulkPublish`,
        method: "POST",
        data: body,
        config: {
          params
        }
      }),
      invalidatesTags: (_res, _error, { model, documentIds }) => documentIds.map((id) => ({ type: "Document", id: `${model}_${id}` }))
    }),
    updateDocument: builder.mutation({
      query: ({ collectionType, model, documentId, data, params }) => ({
        url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ""}`,
        method: "PUT",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {
        return [
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
          },
          "Relations",
          { type: "UidAvailability", id: model },
          "RecentDocumentList",
          "RecentDocumentList"
        ];
      },
      async onQueryStarted({ data, ...patch }, { dispatch, queryFulfilled }) {
        const patchResult = dispatch(
          documentApi.util.updateQueryData("getDocument", patch, (draft) => {
            Object.assign(draft.data, data);
          })
        );
        try {
          await queryFulfilled;
        } catch {
          patchResult.undo();
        }
      }
    }),
    unpublishDocument: builder.mutation({
      query: ({ collectionType, model, documentId, params, data }) => ({
        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/unpublish` : `/content-manager/${collectionType}/${model}/actions/unpublish`,
        method: "POST",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {
        return [
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
          },
          "RecentDocumentList"
        ];
      }
    }),
    unpublishManyDocuments: builder.mutation({
      query: ({ model, params, ...body }) => ({
        url: `/content-manager/collection-types/${model}/actions/bulkUnpublish`,
        method: "POST",
        data: body,
        config: {
          params
        }
      }),
      invalidatesTags: (_res, _error, { model, documentIds }) => [
        ...documentIds.map((id) => ({ type: "Document", id: `${model}_${id}` })),
        "RecentDocumentList"
      ]
    })
  })
});
var {
  useAutoCloneDocumentMutation,
  useCloneDocumentMutation,
  useCreateDocumentMutation,
  useDeleteDocumentMutation,
  useDeleteManyDocumentsMutation,
  useDiscardDocumentMutation,
  useGetAllDocumentsQuery,
  useLazyGetDocumentQuery,
  useGetDocumentQuery,
  useLazyGetDraftRelationCountQuery,
  useGetManyDraftRelationCountQuery,
  usePublishDocumentMutation,
  usePublishManyDocumentsMutation,
  useUpdateDocumentMutation,
  useUnpublishDocumentMutation,
  useUnpublishManyDocumentsMutation
} = documentApi;
var buildValidParams = (query) => {
  if (!query)
    return query;
  const { plugins: _, ...validQueryParams } = {
    ...query,
    ...Object.values((query == null ? void 0 : query.plugins) ?? {}).reduce(
      (acc, current) => Object.assign(acc, current),
      {}
    )
  };
  return validQueryParams;
};
var isBaseQueryError = (error) => {
  return error.name !== void 0;
};
var arrayValidator = (attribute, options) => ({
  message: errorsTrads.required,
  test(value) {
    if (options.status === "draft") {
      return true;
    }
    if (!attribute.required) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (Array.isArray(value) && value.length === 0) {
      return false;
    }
    return true;
  }
});
var createYupSchema = (attributes = {}, components = {}, options = { status: null }) => {
  const createModelSchema = (attributes2) => create5().shape(
    Object.entries(attributes2).reduce((acc, [name, attribute]) => {
      if (DOCUMENT_META_FIELDS.includes(name)) {
        return acc;
      }
      const validations = [
        addNullableValidation,
        addRequiredValidation,
        addMinLengthValidation,
        addMaxLengthValidation,
        addMinValidation,
        addMaxValidation,
        addRegexValidation
      ].map((fn) => fn(attribute, options));
      const transformSchema = (0, import_pipe.default)(...validations);
      switch (attribute.type) {
        case "component": {
          const { attributes: attributes3 } = components[attribute.component];
          if (attribute.repeatable) {
            return {
              ...acc,
              [name]: transformSchema(
                create6().of(createModelSchema(attributes3).nullable(false))
              ).test(arrayValidator(attribute, options))
            };
          } else {
            return {
              ...acc,
              [name]: transformSchema(createModelSchema(attributes3).nullable())
            };
          }
        }
        case "dynamiczone":
          return {
            ...acc,
            [name]: transformSchema(
              create6().of(
                create7(
                  (data) => {
                    var _a;
                    const attributes3 = (_a = components == null ? void 0 : components[data == null ? void 0 : data.__component]) == null ? void 0 : _a.attributes;
                    const validation = create5().shape({
                      __component: create3().required().oneOf(Object.keys(components))
                    }).nullable(false);
                    if (!attributes3) {
                      return validation;
                    }
                    return validation.concat(createModelSchema(attributes3));
                  }
                )
              )
            ).test(arrayValidator(attribute, options))
          };
        case "relation":
          return {
            ...acc,
            [name]: transformSchema(
              create7((value) => {
                if (!value) {
                  return create().nullable(true);
                } else if (Array.isArray(value)) {
                  return create6().of(
                    create5().shape({
                      id: create4().required()
                    })
                  );
                } else if (typeof value === "object") {
                  return create5();
                } else {
                  return create().test(
                    "type-error",
                    "Relation values must be either null, an array of objects with {id} or an object.",
                    () => false
                  );
                }
              })
            )
          };
        default:
          return {
            ...acc,
            [name]: transformSchema(createAttributeSchema(attribute))
          };
      }
    }, {})
  ).default(null);
  return createModelSchema(attributes);
};
var createAttributeSchema = (attribute) => {
  switch (attribute.type) {
    case "biginteger":
      return create3().matches(/^-?\d*$/);
    case "boolean":
      return create2();
    case "blocks":
      return create().test("isBlocks", errorsTrads.json, (value) => {
        if (!value || Array.isArray(value)) {
          return true;
        } else {
          return false;
        }
      });
    case "decimal":
    case "float":
    case "integer":
      return create4();
    case "email":
      return create3().email(errorsTrads.email);
    case "enumeration":
      return create3().oneOf([...attribute.enum, null]);
    case "json":
      return create().test("isJSON", errorsTrads.json, (value) => {
        if (!value || typeof value === "string" && value.length === 0) {
          return true;
        }
        if (typeof value === "object") {
          try {
            JSON.stringify(value);
            return true;
          } catch (err) {
            return false;
          }
        }
        try {
          JSON.parse(value);
          return true;
        } catch (err) {
          return false;
        }
      });
    case "password":
    case "richtext":
    case "string":
    case "text":
      return create3();
    case "uid":
      return create3().matches(/^[A-Za-z0-9-_.~]*$/);
    default:
      return create();
  }
};
var nullableSchema = (schema) => {
  return (schema == null ? void 0 : schema.nullable) ? schema.nullable() : (
    // In some cases '.nullable' will not be available on the schema.
    // e.g. when the schema has been built using yup.lazy (e.g. for relations).
    // In these cases we should just return the schema as it is.
    schema
  );
};
var addNullableValidation = () => (schema) => {
  return nullableSchema(schema);
};
var addRequiredValidation = (attribute, options) => (schema) => {
  if (options.status === "draft" || !attribute.required) {
    return schema;
  }
  if (attribute.required && "required" in schema) {
    return schema.required(errorsTrads.required);
  }
  return schema;
};
var addMinLengthValidation = (attribute, options) => (schema) => {
  if (options.status === "draft") {
    return schema;
  }
  if ("minLength" in attribute && attribute.minLength && Number.isInteger(attribute.minLength) && "min" in schema) {
    return schema.min(attribute.minLength, {
      ...errorsTrads.minLength,
      values: {
        min: attribute.minLength
      }
    });
  }
  return schema;
};
var addMaxLengthValidation = (attribute) => (schema) => {
  if ("maxLength" in attribute && attribute.maxLength && Number.isInteger(attribute.maxLength) && "max" in schema) {
    return schema.max(attribute.maxLength, {
      ...errorsTrads.maxLength,
      values: {
        max: attribute.maxLength
      }
    });
  }
  return schema;
};
var addMinValidation = (attribute, options) => (schema) => {
  if (options.status === "draft") {
    return schema;
  }
  if ("min" in attribute && "min" in schema) {
    const min = toInteger(attribute.min);
    if (min) {
      return schema.min(min, {
        ...errorsTrads.min,
        values: {
          min
        }
      });
    }
  }
  return schema;
};
var addMaxValidation = (attribute) => (schema) => {
  if ("max" in attribute) {
    const max = toInteger(attribute.max);
    if ("max" in schema && max) {
      return schema.max(max, {
        ...errorsTrads.max,
        values: {
          max
        }
      });
    }
  }
  return schema;
};
var toInteger = (val) => {
  if (typeof val === "number" || val === void 0) {
    return val;
  } else {
    const num = Number(val);
    return isNaN(num) ? void 0 : num;
  }
};
var addRegexValidation = (attribute) => (schema) => {
  if ("regex" in attribute && attribute.regex && "matches" in schema) {
    return schema.matches(new RegExp(attribute.regex), {
      message: {
        id: errorsTrads.regex.id,
        defaultMessage: "The value does not match the defined pattern."
      },
      excludeEmptyString: !attribute.required
    });
  }
  return schema;
};
var initApi = contentManagerApi.injectEndpoints({
  endpoints: (builder) => ({
    getInitialData: builder.query({
      query: () => "/content-manager/init",
      transformResponse: (response) => response.data,
      providesTags: ["InitialData"]
    })
  })
});
var { useGetInitialDataQuery } = initApi;
var useContentTypeSchema = (model) => {
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const { data, error, isLoading, isFetching } = useGetInitialDataQuery(void 0);
  const { components, contentType, contentTypes } = React11.useMemo(() => {
    const contentType2 = data == null ? void 0 : data.contentTypes.find((ct) => ct.uid === model);
    const componentsByKey = data == null ? void 0 : data.components.reduce((acc, component) => {
      acc[component.uid] = component;
      return acc;
    }, {});
    const components2 = extractContentTypeComponents(contentType2 == null ? void 0 : contentType2.attributes, componentsByKey);
    return {
      components: Object.keys(components2).length === 0 ? void 0 : components2,
      contentType: contentType2,
      contentTypes: (data == null ? void 0 : data.contentTypes) ?? []
    };
  }, [model, data]);
  React11.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: formatAPIError(error)
      });
    }
  }, [toggleNotification, error, formatAPIError]);
  return {
    // This must be memoized to avoid inifiinite re-renders where the empty object is different everytime.
    components: React11.useMemo(() => components ?? {}, [components]),
    schema: contentType,
    schemas: contentTypes,
    isLoading: isLoading || isFetching
  };
};
var extractContentTypeComponents = (attributes = {}, allComponents = {}) => {
  const getComponents = (attributes2) => {
    return attributes2.reduce((acc, attribute) => {
      var _a;
      if (attribute.type === "component") {
        const componentAttributes = Object.values(
          ((_a = allComponents[attribute.component]) == null ? void 0 : _a.attributes) ?? {}
        );
        acc.push(attribute.component, ...getComponents(componentAttributes));
      } else if (attribute.type === "dynamiczone") {
        acc.push(
          ...attribute.components,
          ...attribute.components.flatMap((componentUid) => {
            var _a2;
            const componentAttributes = Object.values(
              ((_a2 = allComponents[componentUid]) == null ? void 0 : _a2.attributes) ?? {}
            );
            return getComponents(componentAttributes);
          })
        );
      }
      return acc;
    }, []);
  };
  const componentUids = getComponents(Object.values(attributes));
  const uniqueComponentUids = [...new Set(componentUids)];
  const componentsByKey = uniqueComponentUids.reduce((acc, uid) => {
    acc[uid] = allComponents[uid];
    return acc;
  }, {});
  return componentsByKey;
};
var HOOKS = {
  /**
   * Hook that allows to mutate the displayed headers of the list view table
   * @constant
   * @type {string}
   */
  INJECT_COLUMN_IN_TABLE: "Admin/CM/pages/ListView/inject-column-in-table",
  /**
   * Hook that allows to mutate the CM's collection types links pre-set filters
   * @constant
   * @type {string}
   */
  MUTATE_COLLECTION_TYPES_LINKS: "Admin/CM/pages/App/mutate-collection-types-links",
  /**
   * Hook that allows to mutate the CM's edit view layout
   * @constant
   * @type {string}
   */
  MUTATE_EDIT_VIEW_LAYOUT: "Admin/CM/pages/EditView/mutate-edit-view-layout",
  /**
   * Hook that allows to mutate the CM's single types links pre-set filters
   * @constant
   * @type {string}
   */
  MUTATE_SINGLE_TYPES_LINKS: "Admin/CM/pages/App/mutate-single-types-links"
};
var contentTypesApi = contentManagerApi.injectEndpoints({
  endpoints: (builder) => ({
    getContentTypeConfiguration: builder.query({
      query: (uid) => ({
        url: `/content-manager/content-types/${uid}/configuration`,
        method: "GET"
      }),
      transformResponse: (response) => response.data,
      providesTags: (_result, _error, uid) => [
        { type: "ContentTypesConfiguration", id: uid },
        { type: "ContentTypeSettings", id: "LIST" }
      ]
    }),
    getAllContentTypeSettings: builder.query({
      query: () => "/content-manager/content-types-settings",
      transformResponse: (response) => response.data,
      providesTags: [{ type: "ContentTypeSettings", id: "LIST" }]
    }),
    updateContentTypeConfiguration: builder.mutation({
      query: ({ uid, ...body }) => ({
        url: `/content-manager/content-types/${uid}/configuration`,
        method: "PUT",
        data: body
      }),
      transformResponse: (response) => response.data,
      invalidatesTags: (_result, _error, { uid }) => [
        { type: "ContentTypesConfiguration", id: uid },
        { type: "ContentTypeSettings", id: "LIST" },
        // Is this necessary?
        { type: "InitialData" }
      ]
    })
  })
});
var {
  useGetContentTypeConfigurationQuery,
  useGetAllContentTypeSettingsQuery,
  useUpdateContentTypeConfigurationMutation
} = contentTypesApi;
var checkIfAttributeIsDisplayable = (attribute) => {
  const { type } = attribute;
  if (type === "relation") {
    return !attribute.relation.toLowerCase().includes("morph");
  }
  return !["json", "dynamiczone", "richtext", "password", "blocks"].includes(type) && !!type;
};
var getMainField = (attribute, mainFieldName, { schemas, components }) => {
  var _a;
  if (!mainFieldName) {
    return void 0;
  }
  const mainFieldType = attribute.type === "component" ? components[attribute.component].attributes[mainFieldName].type : (
    // @ts-expect-error  `targetModel` does exist on the attribute for a relation.
    (_a = schemas.find((schema) => schema.uid === attribute.targetModel)) == null ? void 0 : _a.attributes[mainFieldName].type
  );
  return {
    name: mainFieldName,
    type: mainFieldType ?? "string"
  };
};
var DEFAULT_SETTINGS = {
  bulkable: false,
  filterable: false,
  searchable: false,
  pagination: false,
  defaultSortBy: "",
  defaultSortOrder: "asc",
  mainField: "id",
  pageSize: 10
};
var useDocumentLayout = (model) => {
  const { schema, components } = useDocument({ model, collectionType: "" }, { skip: true });
  const [{ query }] = useQueryParams();
  const runHookWaterfall = useStrapiApp("useDocumentLayout", (state) => state.runHookWaterfall);
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const { isLoading: isLoadingSchemas, schemas } = useContentTypeSchema();
  const {
    data,
    isLoading: isLoadingConfigs,
    error,
    isFetching: isFetchingConfigs
  } = useGetContentTypeConfigurationQuery(model);
  const isLoading = isLoadingSchemas || isFetchingConfigs || isLoadingConfigs;
  React11.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: formatAPIError(error)
      });
    }
  }, [error, formatAPIError, toggleNotification]);
  const editLayout = React11.useMemo(
    () => data && !isLoading ? formatEditLayout(data, { schemas, schema, components }) : {
      layout: [],
      components: {},
      metadatas: {},
      options: {},
      settings: DEFAULT_SETTINGS
    },
    [data, isLoading, schemas, schema, components]
  );
  const listLayout = React11.useMemo(() => {
    return data && !isLoading ? formatListLayout(data, { schemas, schema, components }) : {
      layout: [],
      metadatas: {},
      options: {},
      settings: DEFAULT_SETTINGS
    };
  }, [data, isLoading, schemas, schema, components]);
  const { layout: edit } = React11.useMemo(
    () => runHookWaterfall(HOOKS.MUTATE_EDIT_VIEW_LAYOUT, {
      layout: editLayout,
      query
    }),
    [editLayout, query, runHookWaterfall]
  );
  return {
    error,
    isLoading,
    edit,
    list: listLayout
  };
};
var useDocLayout = () => {
  const { model } = useDoc();
  return useDocumentLayout(model);
};
var formatEditLayout = (data, {
  schemas,
  schema,
  components
}) => {
  let currentPanelIndex = 0;
  const panelledEditAttributes = convertEditLayoutToFieldLayouts(
    data.contentType.layouts.edit,
    schema == null ? void 0 : schema.attributes,
    data.contentType.metadatas,
    { configurations: data.components, schemas: components },
    schemas
  ).reduce((panels, row) => {
    if (row.some((field) => field.type === "dynamiczone")) {
      panels.push([row]);
      currentPanelIndex += 2;
    } else {
      if (!panels[currentPanelIndex]) {
        panels.push([row]);
      } else {
        panels[currentPanelIndex].push(row);
      }
    }
    return panels;
  }, []);
  const componentEditAttributes = Object.entries(data.components).reduce(
    (acc, [uid, configuration]) => {
      acc[uid] = {
        layout: convertEditLayoutToFieldLayouts(
          configuration.layouts.edit,
          components[uid].attributes,
          configuration.metadatas,
          { configurations: data.components, schemas: components }
        ),
        settings: {
          ...configuration.settings,
          icon: components[uid].info.icon,
          displayName: components[uid].info.displayName
        }
      };
      return acc;
    },
    {}
  );
  const editMetadatas = Object.entries(data.contentType.metadatas).reduce(
    (acc, [attribute, metadata]) => {
      return {
        ...acc,
        [attribute]: metadata.edit
      };
    },
    {}
  );
  return {
    layout: panelledEditAttributes,
    components: componentEditAttributes,
    metadatas: editMetadatas,
    settings: {
      ...data.contentType.settings,
      displayName: schema == null ? void 0 : schema.info.displayName
    },
    options: {
      ...schema == null ? void 0 : schema.options,
      ...schema == null ? void 0 : schema.pluginOptions,
      ...data.contentType.options
    }
  };
};
var convertEditLayoutToFieldLayouts = (rows, attributes = {}, metadatas, components, schemas = []) => {
  return rows.map(
    (row) => row.map((field) => {
      const attribute = attributes[field.name];
      if (!attribute) {
        return null;
      }
      const { edit: metadata } = metadatas[field.name];
      const settings = attribute.type === "component" && components ? components.configurations[attribute.component].settings : {};
      return {
        attribute,
        disabled: !metadata.editable,
        hint: metadata.description,
        label: metadata.label ?? "",
        name: field.name,
        // @ts-expect-error  mainField does exist on the metadata for a relation.
        mainField: getMainField(attribute, metadata.mainField || settings.mainField, {
          schemas,
          components: (components == null ? void 0 : components.schemas) ?? {}
        }),
        placeholder: metadata.placeholder ?? "",
        required: attribute.required ?? false,
        size: field.size,
        unique: "unique" in attribute ? attribute.unique : false,
        visible: metadata.visible ?? true,
        type: attribute.type
      };
    }).filter((field) => field !== null)
  );
};
var formatListLayout = (data, {
  schemas,
  schema,
  components
}) => {
  const listMetadatas = Object.entries(data.contentType.metadatas).reduce(
    (acc, [attribute, metadata]) => {
      return {
        ...acc,
        [attribute]: metadata.list
      };
    },
    {}
  );
  const listAttributes = convertListLayoutToFieldLayouts(
    data.contentType.layouts.list,
    schema == null ? void 0 : schema.attributes,
    listMetadatas,
    { configurations: data.components, schemas: components },
    schemas
  );
  return {
    layout: listAttributes,
    settings: { ...data.contentType.settings, displayName: schema == null ? void 0 : schema.info.displayName },
    metadatas: listMetadatas,
    options: {
      ...schema == null ? void 0 : schema.options,
      ...schema == null ? void 0 : schema.pluginOptions,
      ...data.contentType.options
    }
  };
};
var convertListLayoutToFieldLayouts = (columns, attributes = {}, metadatas, components, schemas = []) => {
  return columns.map((name) => {
    const attribute = attributes[name];
    if (!attribute) {
      return null;
    }
    const metadata = metadatas[name];
    const settings = attribute.type === "component" && components ? components.configurations[attribute.component].settings : {};
    return {
      attribute,
      label: metadata.label ?? "",
      mainField: getMainField(attribute, metadata.mainField || settings.mainField, {
        schemas,
        components: (components == null ? void 0 : components.schemas) ?? {}
      }),
      name,
      searchable: metadata.searchable ?? true,
      sortable: metadata.sortable ?? true
    };
  }).filter((field) => field !== null);
};
var useDocument = (args, opts) => {
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const { formatMessage: formatMessage3 } = useIntl();
  const {
    currentData: data,
    isLoading: isLoadingDocument,
    isFetching: isFetchingDocument,
    error
  } = useGetDocumentQuery(args, {
    ...opts,
    skip: !args.documentId && args.collectionType !== SINGLE_TYPES || (opts == null ? void 0 : opts.skip)
  });
  const document = data == null ? void 0 : data.data;
  const meta = data == null ? void 0 : data.meta;
  const {
    components,
    schema,
    schemas,
    isLoading: isLoadingSchema
  } = useContentTypeSchema(args.model);
  const isSingleType = (schema == null ? void 0 : schema.kind) === "singleType";
  const getTitle = (mainField) => {
    if (mainField !== "id" && (document == null ? void 0 : document[mainField])) {
      return document[mainField];
    }
    if (isSingleType && (schema == null ? void 0 : schema.info.displayName)) {
      return schema.info.displayName;
    }
    return formatMessage3({
      id: "content-manager.containers.untitled",
      defaultMessage: "Untitled"
    });
  };
  React11.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: formatAPIError(error)
      });
    }
  }, [toggleNotification, error, formatAPIError, args.collectionType]);
  const validationSchema = React11.useMemo(() => {
    if (!schema) {
      return null;
    }
    return createYupSchema(schema.attributes, components);
  }, [schema, components]);
  const validate = React11.useCallback(
    (document2) => {
      if (!validationSchema) {
        throw new Error(
          "There is no validation schema generated, this is likely due to the schema not being loaded yet."
        );
      }
      try {
        validationSchema.validateSync(document2, { abortEarly: false, strict: true });
        return null;
      } catch (error2) {
        if (error2 instanceof ValidationError) {
          return getYupValidationErrors(error2);
        }
        throw error2;
      }
    },
    [validationSchema]
  );
  const getInitialFormValues = React11.useCallback(
    (isCreatingDocument = false) => {
      if (!document && !isCreatingDocument && !isSingleType || !schema) {
        return void 0;
      }
      const form = (document == null ? void 0 : document.id) ? document : createDefaultForm(schema, components);
      return transformDocument(schema, components)(form);
    },
    [document, isSingleType, schema, components]
  );
  const isLoading = isLoadingDocument || isFetchingDocument || isLoadingSchema;
  const hasError = !!error;
  return {
    components,
    document,
    meta,
    isLoading,
    hasError,
    schema,
    schemas,
    validate,
    getTitle,
    getInitialFormValues
  };
};
var useDoc = () => {
  const { id, slug, collectionType, origin } = useParams();
  const [{ query }] = useQueryParams();
  const params = React11.useMemo(() => buildValidParams(query), [query]);
  if (!collectionType) {
    throw new Error("Could not find collectionType in url params");
  }
  if (!slug) {
    throw new Error("Could not find model in url params");
  }
  const document = useDocument(
    { documentId: origin || id, model: slug, collectionType, params },
    {
      skip: id === "create" || !origin && !id && collectionType !== SINGLE_TYPES
    }
  );
  const returnId = origin || id === "create" ? void 0 : id;
  return {
    collectionType,
    model: slug,
    id: returnId,
    ...document
  };
};
var useContentManagerContext = () => {
  var _a;
  const {
    collectionType,
    model,
    id,
    components,
    isLoading: isLoadingDoc,
    schema,
    schemas
  } = useDoc();
  const layout = useDocumentLayout(model);
  const form = useForm("useContentManagerContext", (state) => state);
  const isSingleType = collectionType === SINGLE_TYPES;
  const slug = model;
  const isCreatingEntry = id === "create";
  useContentTypeSchema();
  const isLoading = isLoadingDoc || layout.isLoading;
  const error = layout.error;
  return {
    error,
    isLoading,
    // Base metadata
    model,
    collectionType,
    id,
    slug,
    isCreatingEntry,
    isSingleType,
    hasDraftAndPublish: ((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish) ?? false,
    // All schema infos
    components,
    contentType: schema,
    contentTypes: schemas,
    // Form state
    form,
    // layout infos
    layout
  };
};
var prefixPluginTranslations = (trad, pluginId) => {
  return Object.keys(trad).reduce((acc, current) => {
    acc[`${pluginId}.${current}`] = trad[current];
    return acc;
  }, {});
};
var getTranslation = (id) => `content-manager.${id}`;
var DEFAULT_UNEXPECTED_ERROR_MSG = {
  id: "notification.error",
  defaultMessage: "An error occurred, please try again"
};
var useDocumentActions = () => {
  const { toggleNotification } = useNotification();
  const { formatMessage: formatMessage3 } = useIntl();
  const { trackUsage } = useTracking();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const navigate = useNavigate();
  const setCurrentStep = useGuidedTour("useDocumentActions", (state) => state.setCurrentStep);
  const [deleteDocument] = useDeleteDocumentMutation();
  const _delete = React11.useCallback(
    async ({ collectionType, model, documentId, params }, trackerProperty) => {
      try {
        trackUsage("willDeleteEntry", trackerProperty);
        const res = await deleteDocument({
          collectionType,
          model,
          documentId,
          params
        });
        if ("error" in res) {
          toggleNotification({
            type: "danger",
            message: formatAPIError(res.error)
          });
          return { error: res.error };
        }
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: getTranslation("success.record.delete"),
            defaultMessage: "Deleted document"
          })
        });
        trackUsage("didDeleteEntry", trackerProperty);
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        trackUsage("didNotDeleteEntry", { error: err, ...trackerProperty });
        throw err;
      }
    },
    [trackUsage, deleteDocument, toggleNotification, formatMessage3, formatAPIError]
  );
  const [deleteManyDocuments] = useDeleteManyDocumentsMutation();
  const deleteMany = React11.useCallback(
    async ({ model, documentIds, params }) => {
      try {
        trackUsage("willBulkDeleteEntries");
        const res = await deleteManyDocuments({
          model,
          documentIds,
          params
        });
        if ("error" in res) {
          toggleNotification({
            type: "danger",
            message: formatAPIError(res.error)
          });
          return { error: res.error };
        }
        toggleNotification({
          type: "success",
          title: formatMessage3({
            id: getTranslation("success.records.delete"),
            defaultMessage: "Successfully deleted."
          }),
          message: ""
        });
        trackUsage("didBulkDeleteEntries");
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        trackUsage("didNotBulkDeleteEntries");
        throw err;
      }
    },
    [trackUsage, deleteManyDocuments, toggleNotification, formatMessage3, formatAPIError]
  );
  const [discardDocument] = useDiscardDocumentMutation();
  const discard = React11.useCallback(
    async ({ collectionType, model, documentId, params }) => {
      try {
        const res = await discardDocument({
          collectionType,
          model,
          documentId,
          params
        });
        if ("error" in res) {
          toggleNotification({
            type: "danger",
            message: formatAPIError(res.error)
          });
          return { error: res.error };
        }
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: "content-manager.success.record.discard",
            defaultMessage: "Changes discarded"
          })
        });
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [discardDocument, formatAPIError, formatMessage3, toggleNotification]
  );
  const [publishDocument] = usePublishDocumentMutation();
  const publish = React11.useCallback(
    async ({ collectionType, model, documentId, params }, data) => {
      try {
        trackUsage("willPublishEntry");
        const res = await publishDocument({
          collectionType,
          model,
          documentId,
          data,
          params
        });
        if ("error" in res) {
          toggleNotification({ type: "danger", message: formatAPIError(res.error) });
          return { error: res.error };
        }
        trackUsage("didPublishEntry");
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: getTranslation("success.record.publish"),
            defaultMessage: "Published document"
          })
        });
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [trackUsage, publishDocument, toggleNotification, formatMessage3, formatAPIError]
  );
  const [publishManyDocuments] = usePublishManyDocumentsMutation();
  const publishMany = React11.useCallback(
    async ({ model, documentIds, params }) => {
      try {
        const res = await publishManyDocuments({
          model,
          documentIds,
          params
        });
        if ("error" in res) {
          toggleNotification({ type: "danger", message: formatAPIError(res.error) });
          return { error: res.error };
        }
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: getTranslation("success.record.publish"),
            defaultMessage: "Published document"
          })
        });
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [
      // trackUsage,
      publishManyDocuments,
      toggleNotification,
      formatMessage3,
      formatAPIError
    ]
  );
  const [updateDocument] = useUpdateDocumentMutation();
  const update = React11.useCallback(
    async ({ collectionType, model, documentId, params }, data, trackerProperty) => {
      try {
        trackUsage("willEditEntry", trackerProperty);
        const res = await updateDocument({
          collectionType,
          model,
          documentId,
          data,
          params
        });
        if ("error" in res) {
          toggleNotification({ type: "danger", message: formatAPIError(res.error) });
          trackUsage("didNotEditEntry", { error: res.error, ...trackerProperty });
          return { error: res.error };
        }
        trackUsage("didEditEntry", trackerProperty);
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: getTranslation("success.record.save"),
            defaultMessage: "Saved document"
          })
        });
        return res.data;
      } catch (err) {
        trackUsage("didNotEditEntry", { error: err, ...trackerProperty });
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [trackUsage, updateDocument, toggleNotification, formatMessage3, formatAPIError]
  );
  const [unpublishDocument] = useUnpublishDocumentMutation();
  const unpublish = React11.useCallback(
    async ({ collectionType, model, documentId, params }, discardDraft = false) => {
      try {
        trackUsage("willUnpublishEntry");
        const res = await unpublishDocument({
          collectionType,
          model,
          documentId,
          params,
          data: {
            discardDraft
          }
        });
        if ("error" in res) {
          toggleNotification({ type: "danger", message: formatAPIError(res.error) });
          return { error: res.error };
        }
        trackUsage("didUnpublishEntry");
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: getTranslation("success.record.unpublish"),
            defaultMessage: "Unpublished document"
          })
        });
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [trackUsage, unpublishDocument, toggleNotification, formatMessage3, formatAPIError]
  );
  const [unpublishManyDocuments] = useUnpublishManyDocumentsMutation();
  const unpublishMany = React11.useCallback(
    async ({ model, documentIds, params }) => {
      try {
        trackUsage("willBulkUnpublishEntries");
        const res = await unpublishManyDocuments({
          model,
          documentIds,
          params
        });
        if ("error" in res) {
          toggleNotification({ type: "danger", message: formatAPIError(res.error) });
          return { error: res.error };
        }
        trackUsage("didBulkUnpublishEntries");
        toggleNotification({
          type: "success",
          title: formatMessage3({
            id: getTranslation("success.records.unpublish"),
            defaultMessage: "Successfully unpublished."
          }),
          message: ""
        });
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        trackUsage("didNotBulkUnpublishEntries");
        throw err;
      }
    },
    [trackUsage, unpublishManyDocuments, toggleNotification, formatMessage3, formatAPIError]
  );
  const [createDocument] = useCreateDocumentMutation();
  const create8 = React11.useCallback(
    async ({ model, params }, data, trackerProperty) => {
      try {
        const res = await createDocument({
          model,
          data,
          params
        });
        if ("error" in res) {
          toggleNotification({ type: "danger", message: formatAPIError(res.error) });
          trackUsage("didNotCreateEntry", { error: res.error, ...trackerProperty });
          return { error: res.error };
        }
        trackUsage("didCreateEntry", trackerProperty);
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: getTranslation("success.record.save"),
            defaultMessage: "Saved document"
          })
        });
        setCurrentStep("contentManager.success");
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        trackUsage("didNotCreateEntry", { error: err, ...trackerProperty });
        throw err;
      }
    },
    [createDocument, formatAPIError, formatMessage3, toggleNotification, trackUsage]
  );
  const [autoCloneDocument] = useAutoCloneDocumentMutation();
  const autoClone = React11.useCallback(
    async ({ model, sourceId }) => {
      try {
        const res = await autoCloneDocument({
          model,
          sourceId
        });
        if ("error" in res) {
          return { error: res.error };
        }
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: getTranslation("success.record.clone"),
            defaultMessage: "Cloned document"
          })
        });
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        throw err;
      }
    },
    [autoCloneDocument, formatMessage3, toggleNotification]
  );
  const [cloneDocument] = useCloneDocumentMutation();
  const clone = React11.useCallback(
    async ({ model, documentId, params }, body, trackerProperty) => {
      try {
        const { id: _id, ...restBody } = body;
        const res = await cloneDocument({
          model,
          sourceId: documentId,
          data: restBody,
          params
        });
        if ("error" in res) {
          toggleNotification({ type: "danger", message: formatAPIError(res.error) });
          trackUsage("didNotCreateEntry", { error: res.error, ...trackerProperty });
          return { error: res.error };
        }
        trackUsage("didCreateEntry", trackerProperty);
        toggleNotification({
          type: "success",
          message: formatMessage3({
            id: getTranslation("success.record.clone"),
            defaultMessage: "Cloned document"
          })
        });
        navigate(`../../${res.data.data.documentId}`, { relative: "path" });
        return res.data;
      } catch (err) {
        toggleNotification({
          type: "danger",
          message: formatMessage3(DEFAULT_UNEXPECTED_ERROR_MSG)
        });
        trackUsage("didNotCreateEntry", { error: err, ...trackerProperty });
        throw err;
      }
    },
    [cloneDocument, trackUsage, toggleNotification, formatMessage3, formatAPIError, navigate]
  );
  const [getDoc] = useLazyGetDocumentQuery();
  const getDocument = React11.useCallback(
    async (args) => {
      const { data } = await getDoc(args);
      return data;
    },
    [getDoc]
  );
  return {
    autoClone,
    clone,
    create: create8,
    delete: _delete,
    deleteMany,
    discard,
    getDocument,
    publish,
    publishMany,
    unpublish,
    unpublishMany,
    update
  };
};
var ProtectedHistoryPage = React11.lazy(
  () => import("./History-D1PreDSY-AAZRFCG3.js").then((mod) => ({ default: mod.ProtectedHistoryPage }))
);
var routes$2 = [
  {
    path: ":collectionType/:slug/:id/history",
    Component: ProtectedHistoryPage
  },
  {
    path: ":collectionType/:slug/history",
    Component: ProtectedHistoryPage
  }
];
var ProtectedPreviewPage = React11.lazy(
  () => import("./Preview-BNuU0SuQ-IP4UBW72.js").then((mod) => ({ default: mod.ProtectedPreviewPage }))
);
var routes$1 = [
  {
    path: ":collectionType/:slug/:id/preview",
    Component: ProtectedPreviewPage
  },
  {
    path: ":collectionType/:slug/preview",
    Component: ProtectedPreviewPage
  }
];
var ProtectedEditViewPage = (0, import_react.lazy)(
  () => import("./EditViewPage-DrmVmYN0-SWRUAUYY.js").then((mod) => ({ default: mod.ProtectedEditViewPage }))
);
var ProtectedListViewPage = (0, import_react.lazy)(
  () => import("./ListViewPage-Bud_jBDQ-4NZUJE26.js").then((mod) => ({ default: mod.ProtectedListViewPage }))
);
var ProtectedListConfiguration = (0, import_react.lazy)(
  () => import("./ListConfigurationPage-Bbi32isk-G7BO2T2B.js").then((mod) => ({
    default: mod.ProtectedListConfiguration
  }))
);
var ProtectedEditConfigurationPage = (0, import_react.lazy)(
  () => import("./EditConfigurationPage-COe6hjPC-ZNQ7UM72.js").then((mod) => ({
    default: mod.ProtectedEditConfigurationPage
  }))
);
var ProtectedComponentConfigurationPage = (0, import_react.lazy)(
  () => import("./ComponentConfigurationPage-9_4yUE9L-SOG5NGLI.js").then((mod) => ({
    default: mod.ProtectedComponentConfigurationPage
  }))
);
var NoPermissions = (0, import_react.lazy)(
  () => import("./NoPermissionsPage-CMdM-dCo-HL3KPHVB.js").then((mod) => ({ default: mod.NoPermissions }))
);
var NoContentType = (0, import_react.lazy)(
  () => import("./NoContentTypePage-DVhkugsf-5Z4WZNNM.js").then((mod) => ({ default: mod.NoContentType }))
);
var CollectionTypePages = () => {
  const { collectionType } = useParams();
  if (collectionType !== COLLECTION_TYPES && collectionType !== SINGLE_TYPES) {
    return (0, import_jsx_runtime.jsx)(Navigate, { to: "/404" });
  }
  return collectionType === COLLECTION_TYPES ? (0, import_jsx_runtime.jsx)(ProtectedListViewPage, {}) : (0, import_jsx_runtime.jsx)(ProtectedEditViewPage, {});
};
var CLONE_RELATIVE_PATH = ":collectionType/:slug/clone/:origin";
var CLONE_PATH = `/content-manager/${CLONE_RELATIVE_PATH}`;
var LIST_RELATIVE_PATH = ":collectionType/:slug";
var LIST_PATH = `/content-manager/collection-types/:slug`;
var routes = [
  {
    path: LIST_RELATIVE_PATH,
    element: (0, import_jsx_runtime.jsx)(CollectionTypePages, {})
  },
  {
    path: ":collectionType/:slug/:id",
    Component: ProtectedEditViewPage
  },
  {
    path: CLONE_RELATIVE_PATH,
    Component: ProtectedEditViewPage
  },
  {
    path: ":collectionType/:slug/configurations/list",
    Component: ProtectedListConfiguration
  },
  {
    path: "components/:slug/configurations/edit",
    Component: ProtectedComponentConfigurationPage
  },
  {
    path: ":collectionType/:slug/configurations/edit",
    Component: ProtectedEditConfigurationPage
  },
  {
    path: "403",
    Component: NoPermissions
  },
  {
    path: "no-content-types",
    Component: NoContentType
  },
  ...routes$2,
  ...routes$1
];
var DocumentActions = ({ actions: actions2 }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const [primaryAction, secondaryAction, ...restActions] = actions2.filter((action) => {
    if (action.position === void 0) {
      return true;
    }
    const positions = Array.isArray(action.position) ? action.position : [action.position];
    return positions.includes("panel");
  });
  if (!primaryAction) {
    return null;
  }
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 2, alignItems: "stretch", width: "100%", children: [
    (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      (0, import_jsx_runtime.jsx)(DocumentActionButton, { ...primaryAction, variant: primaryAction.variant || "default" }),
      restActions.length > 0 ? (0, import_jsx_runtime.jsx)(
        DocumentActionsMenu,
        {
          actions: restActions,
          label: formatMessage3({
            id: "content-manager.containers.edit.panels.default.more-actions",
            defaultMessage: "More document actions"
          })
        }
      ) : null
    ] }),
    secondaryAction ? (0, import_jsx_runtime.jsx)(
      DocumentActionButton,
      {
        ...secondaryAction,
        variant: secondaryAction.variant || "secondary"
      }
    ) : null
  ] });
};
var DocumentActionButton = (action) => {
  var _a, _b, _c;
  const [dialogId, setDialogId] = React11.useState(null);
  const { toggleNotification } = useNotification();
  const handleClick = (action2) => async (e) => {
    const { onClick = () => false, dialog, id } = action2;
    const muteDialog = await onClick(e);
    if (dialog && !muteDialog) {
      switch (dialog.type) {
        case "notification":
          toggleNotification({
            title: dialog.title,
            message: dialog.content,
            type: dialog.status,
            timeout: dialog.timeout,
            onClose: dialog.onClose
          });
          break;
        case "dialog":
        case "modal":
          e.preventDefault();
          setDialogId(id);
      }
    }
  };
  const handleClose = () => {
    setDialogId(null);
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(
      Button,
      {
        flex: "auto",
        startIcon: action.icon,
        disabled: action.disabled,
        onClick: handleClick(action),
        justifyContent: "center",
        variant: action.variant || "default",
        paddingTop: "7px",
        paddingBottom: "7px",
        children: action.label
      }
    ),
    ((_a = action.dialog) == null ? void 0 : _a.type) === "dialog" ? (0, import_jsx_runtime.jsx)(
      DocumentActionConfirmDialog,
      {
        ...action.dialog,
        variant: ((_b = action.dialog) == null ? void 0 : _b.variant) ?? action.variant,
        isOpen: dialogId === action.id,
        onClose: handleClose
      }
    ) : null,
    ((_c = action.dialog) == null ? void 0 : _c.type) === "modal" ? (0, import_jsx_runtime.jsx)(
      DocumentActionModal,
      {
        ...action.dialog,
        onModalClose: handleClose,
        isOpen: dialogId === action.id
      }
    ) : null
  ] });
};
var MenuItem = dt(Menu.Item)`
  &:hover {
    background: ${({ theme, isVariantDanger, isDisabled }) => isVariantDanger && !isDisabled ? theme.colors.danger100 : "neutral"};
  }
`;
var DocumentActionsMenu = ({
  actions: actions2,
  children,
  label,
  variant = "tertiary"
}) => {
  const [isOpen, setIsOpen] = React11.useState(false);
  const [dialogId, setDialogId] = React11.useState(null);
  const { formatMessage: formatMessage3 } = useIntl();
  const { toggleNotification } = useNotification();
  const isDisabled = actions2.every((action) => action.disabled) || actions2.length === 0;
  const handleClick = (action) => async (e) => {
    const { onClick = () => false, dialog, id } = action;
    const muteDialog = await onClick(e);
    if (dialog && !muteDialog) {
      switch (dialog.type) {
        case "notification":
          toggleNotification({
            title: dialog.title,
            message: dialog.content,
            type: dialog.status,
            timeout: dialog.timeout,
            onClose: dialog.onClose
          });
          break;
        case "dialog":
        case "modal":
          setDialogId(id);
      }
    }
  };
  const handleClose = () => {
    setDialogId(null);
    setIsOpen(false);
  };
  return (0, import_jsx_runtime.jsxs)(Menu.Root, { open: isOpen, onOpenChange: setIsOpen, children: [
    (0, import_jsx_runtime.jsxs)(
      Menu.Trigger,
      {
        disabled: isDisabled,
        size: "S",
        endIcon: null,
        paddingTop: "4px",
        paddingLeft: "7px",
        paddingRight: "7px",
        variant,
        children: [
          (0, import_jsx_runtime.jsx)(ForwardRef$1R, { "aria-hidden": true, focusable: false }),
          (0, import_jsx_runtime.jsx)(VisuallyHidden, { tag: "span", children: label || formatMessage3({
            id: "content-manager.containers.edit.panels.default.more-actions",
            defaultMessage: "More document actions"
          }) })
        ]
      }
    ),
    (0, import_jsx_runtime.jsxs)(Menu.Content, { maxHeight: void 0, popoverPlacement: "bottom-end", children: [
      actions2.map((action) => {
        return (0, import_jsx_runtime.jsx)(
          MenuItem,
          {
            disabled: action.disabled,
            onSelect: handleClick(action),
            display: "block",
            isVariantDanger: action.variant === "danger",
            isDisabled: action.disabled,
            children: (0, import_jsx_runtime.jsx)(Flex, { justifyContent: "space-between", gap: 4, children: (0, import_jsx_runtime.jsxs)(
              Flex,
              {
                color: !action.disabled ? convertActionVariantToColor(action.variant) : "inherit",
                gap: 2,
                tag: "span",
                children: [
                  (0, import_jsx_runtime.jsx)(
                    Flex,
                    {
                      tag: "span",
                      color: !action.disabled ? convertActionVariantToIconColor(action.variant) : "inherit",
                      children: action.icon
                    }
                  ),
                  action.label
                ]
              }
            ) })
          },
          action.id
        );
      }),
      children
    ] }),
    actions2.map((action) => {
      var _a, _b;
      return (0, import_jsx_runtime.jsxs)(React11.Fragment, { children: [
        ((_a = action.dialog) == null ? void 0 : _a.type) === "dialog" ? (0, import_jsx_runtime.jsx)(
          DocumentActionConfirmDialog,
          {
            ...action.dialog,
            variant: action.variant,
            isOpen: dialogId === action.id,
            onClose: handleClose
          }
        ) : null,
        ((_b = action.dialog) == null ? void 0 : _b.type) === "modal" ? (0, import_jsx_runtime.jsx)(
          DocumentActionModal,
          {
            ...action.dialog,
            onModalClose: handleClose,
            isOpen: dialogId === action.id
          }
        ) : null
      ] }, action.id);
    })
  ] });
};
var convertActionVariantToColor = (variant = "secondary") => {
  switch (variant) {
    case "danger":
      return "danger600";
    case "secondary":
      return void 0;
    case "success":
      return "success600";
    default:
      return "primary600";
  }
};
var convertActionVariantToIconColor = (variant = "secondary") => {
  switch (variant) {
    case "danger":
      return "danger600";
    case "secondary":
      return "neutral500";
    case "success":
      return "success600";
    default:
      return "primary600";
  }
};
var DocumentActionConfirmDialog = ({
  onClose,
  onCancel,
  onConfirm,
  title,
  content,
  isOpen,
  variant = "secondary"
}) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const handleClose = async () => {
    if (onCancel) {
      await onCancel();
    }
    onClose();
  };
  const handleConfirm = async () => {
    if (onConfirm) {
      await onConfirm();
    }
    onClose();
  };
  return (0, import_jsx_runtime.jsx)(Dialog.Root, { open: isOpen, onOpenChange: handleClose, children: (0, import_jsx_runtime.jsxs)(Dialog.Content, { children: [
    (0, import_jsx_runtime.jsx)(Dialog.Header, { children: title }),
    (0, import_jsx_runtime.jsx)(Dialog.Body, { children: content }),
    (0, import_jsx_runtime.jsxs)(Dialog.Footer, { children: [
      (0, import_jsx_runtime.jsx)(Dialog.Cancel, { children: (0, import_jsx_runtime.jsx)(Button, { variant: "tertiary", fullWidth: true, children: formatMessage3({
        id: "app.components.Button.cancel",
        defaultMessage: "Cancel"
      }) }) }),
      (0, import_jsx_runtime.jsx)(Button, { onClick: handleConfirm, variant, fullWidth: true, children: formatMessage3({
        id: "app.components.Button.confirm",
        defaultMessage: "Confirm"
      }) })
    ] })
  ] }) });
};
var DocumentActionModal = ({
  isOpen,
  title,
  onClose,
  footer: Footer,
  content: Content,
  onModalClose
}) => {
  const handleClose = () => {
    if (onClose) {
      onClose();
    }
    onModalClose();
  };
  return (0, import_jsx_runtime.jsx)(Modal.Root, { open: isOpen, onOpenChange: handleClose, children: (0, import_jsx_runtime.jsxs)(Modal.Content, { children: [
    (0, import_jsx_runtime.jsx)(Modal.Header, { children: (0, import_jsx_runtime.jsx)(Modal.Title, { children: title }) }),
    typeof Content === "function" ? (0, import_jsx_runtime.jsx)(Content, { onClose: handleClose }) : (0, import_jsx_runtime.jsx)(Modal.Body, { children: Content }),
    typeof Footer === "function" ? (0, import_jsx_runtime.jsx)(Footer, { onClose: handleClose }) : Footer
  ] }) });
};
var transformData = (data) => {
  if (Array.isArray(data)) {
    return data.map(transformData);
  }
  if (typeof data === "object" && data !== null) {
    if ("apiData" in data) {
      return data.apiData;
    }
    return (0, import_mapValues.default)(transformData)(data);
  }
  return data;
};
var PublishAction$1 = ({
  activeTab,
  documentId,
  model,
  collectionType,
  meta,
  document
}) => {
  var _a;
  const { schema } = useDoc();
  const navigate = useNavigate();
  const { toggleNotification } = useNotification();
  const { _unstableFormatValidationErrors: formatValidationErrors } = useAPIErrorHandler();
  const isListView = useMatch(LIST_PATH) !== null;
  const isCloning = useMatch(CLONE_PATH) !== null;
  const { id } = useParams();
  const { formatMessage: formatMessage3 } = useIntl();
  const canPublish = useDocumentRBAC("PublishAction", ({ canPublish: canPublish2 }) => canPublish2);
  const { publish } = useDocumentActions();
  const [
    countDraftRelations,
    { isLoading: isLoadingDraftRelations, isError: isErrorDraftRelations }
  ] = useLazyGetDraftRelationCountQuery();
  const [localCountOfDraftRelations, setLocalCountOfDraftRelations] = React11.useState(0);
  const [serverCountOfDraftRelations, setServerCountOfDraftRelations] = React11.useState(0);
  const [{ query, rawQuery }] = useQueryParams();
  const params = React11.useMemo(() => buildValidParams(query), [query]);
  const modified = useForm("PublishAction", ({ modified: modified2 }) => modified2);
  const setSubmitting = useForm("PublishAction", ({ setSubmitting: setSubmitting2 }) => setSubmitting2);
  const isSubmitting = useForm("PublishAction", ({ isSubmitting: isSubmitting2 }) => isSubmitting2);
  const validate = useForm("PublishAction", (state) => state.validate);
  const setErrors = useForm("PublishAction", (state) => state.setErrors);
  const formValues = useForm("PublishAction", ({ values }) => values);
  React11.useEffect(() => {
    if (isErrorDraftRelations) {
      toggleNotification({
        type: "danger",
        message: formatMessage3({
          id: getTranslation("error.records.fetch-draft-relatons"),
          defaultMessage: "An error occurred while fetching draft relations on this document."
        })
      });
    }
  }, [isErrorDraftRelations, toggleNotification, formatMessage3]);
  React11.useEffect(() => {
    const localDraftRelations = /* @__PURE__ */ new Set();
    const extractDraftRelations = (data) => {
      const relations = data.connect || [];
      relations.forEach((relation) => {
        if (relation.status === "draft") {
          localDraftRelations.add(relation.id);
        }
      });
    };
    const traverseAndExtract = (data) => {
      Object.entries(data).forEach(([key, value]) => {
        if (key === "connect" && Array.isArray(value)) {
          extractDraftRelations({ connect: value });
        } else if (typeof value === "object" && value !== null) {
          traverseAndExtract(value);
        }
      });
    };
    if (!documentId || modified) {
      traverseAndExtract(formValues);
      setLocalCountOfDraftRelations(localDraftRelations.size);
    }
  }, [documentId, modified, formValues, setLocalCountOfDraftRelations]);
  React11.useEffect(() => {
    if (!document || !document.documentId || isListView) {
      return;
    }
    const fetchDraftRelationsCount = async () => {
      const { data, error } = await countDraftRelations({
        collectionType,
        model,
        documentId,
        params
      });
      if (error) {
        throw error;
      }
      if (data) {
        setServerCountOfDraftRelations(data.data);
      }
    };
    fetchDraftRelationsCount();
  }, [isListView, document, documentId, countDraftRelations, collectionType, model, params]);
  const isDocumentPublished = ((document == null ? void 0 : document[PUBLISHED_AT_ATTRIBUTE_NAME]) || (meta == null ? void 0 : meta.availableStatus.some((doc) => doc[PUBLISHED_AT_ATTRIBUTE_NAME] !== null))) && (document == null ? void 0 : document.status) !== "modified";
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  const performPublish = async () => {
    setSubmitting(true);
    try {
      const { errors } = await validate(true, {
        status: "published"
      });
      if (errors) {
        toggleNotification({
          type: "danger",
          message: formatMessage3({
            id: "content-manager.validation.error",
            defaultMessage: "There are validation errors in your document. Please fix them before saving."
          })
        });
        return;
      }
      const res = await publish(
        {
          collectionType,
          model,
          documentId,
          params
        },
        transformData(formValues)
      );
      if ("data" in res && collectionType !== SINGLE_TYPES) {
        if (id === "create") {
          navigate({
            pathname: `../${collectionType}/${model}/${res.data.documentId}`,
            search: rawQuery
          });
        }
      } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
        setErrors(formatValidationErrors(res.error));
      }
    } finally {
      setSubmitting(false);
    }
  };
  const totalDraftRelations = localCountOfDraftRelations + serverCountOfDraftRelations;
  const enableDraftRelationsCount = false;
  const hasDraftRelations = enableDraftRelationsCount;
  return {
    /**
     * Disabled when:
     *  - currently if you're cloning a document we don't support publish & clone at the same time.
     *  - the form is submitting
     *  - the active tab is the published tab
     *  - the document is already published & not modified
     *  - the document is being created & not modified
     *  - the user doesn't have the permission to publish
     */
    disabled: isCloning || isSubmitting || isLoadingDraftRelations || activeTab === "published" || !modified && isDocumentPublished || !modified && !(document == null ? void 0 : document.documentId) || !canPublish,
    label: formatMessage3({
      id: "app.utils.publish",
      defaultMessage: "Publish"
    }),
    onClick: async () => {
      await performPublish();
    },
    dialog: hasDraftRelations ? {
      type: "dialog",
      variant: "danger",
      footer: null,
      title: formatMessage3({
        id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.title`),
        defaultMessage: "Confirmation"
      }),
      content: formatMessage3(
        {
          id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
          defaultMessage: "This entry is related to {count, plural, one {# draft entry} other {# draft entries}}. Publishing it could leave broken links in your app."
        },
        {
          count: totalDraftRelations
        }
      ),
      onConfirm: async () => {
        await performPublish();
      }
    } : void 0
  };
};
PublishAction$1.type = "publish";
PublishAction$1.position = "panel";
var UpdateAction = ({
  activeTab,
  documentId,
  model,
  collectionType
}) => {
  const navigate = useNavigate();
  const { toggleNotification } = useNotification();
  const { _unstableFormatValidationErrors: formatValidationErrors } = useAPIErrorHandler();
  const cloneMatch = useMatch(CLONE_PATH);
  const isCloning = cloneMatch !== null;
  const { formatMessage: formatMessage3 } = useIntl();
  const { create: create8, update, clone } = useDocumentActions();
  const [{ query, rawQuery }] = useQueryParams();
  const params = React11.useMemo(() => buildValidParams(query), [query]);
  const isSubmitting = useForm("UpdateAction", ({ isSubmitting: isSubmitting2 }) => isSubmitting2);
  const modified = useForm("UpdateAction", ({ modified: modified2 }) => modified2);
  const setSubmitting = useForm("UpdateAction", ({ setSubmitting: setSubmitting2 }) => setSubmitting2);
  const document = useForm("UpdateAction", ({ values }) => values);
  const validate = useForm("UpdateAction", (state) => state.validate);
  const setErrors = useForm("UpdateAction", (state) => state.setErrors);
  const resetForm = useForm("PublishAction", ({ resetForm: resetForm2 }) => resetForm2);
  const handleUpdate = React11.useCallback(async () => {
    setSubmitting(true);
    try {
      if (!modified) {
        return;
      }
      const { errors } = await validate(true, {
        status: "draft"
      });
      if (errors) {
        toggleNotification({
          type: "danger",
          message: formatMessage3({
            id: "content-manager.validation.error",
            defaultMessage: "There are validation errors in your document. Please fix them before saving."
          })
        });
        return;
      }
      if (isCloning) {
        const res = await clone(
          {
            model,
            documentId: cloneMatch.params.origin,
            params
          },
          transformData(document)
        );
        if ("data" in res) {
          navigate(
            {
              pathname: `../${res.data.documentId}`,
              search: rawQuery
            },
            { relative: "path" }
          );
        } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        }
      } else if (documentId || collectionType === SINGLE_TYPES) {
        const res = await update(
          {
            collectionType,
            model,
            documentId,
            params
          },
          transformData(document)
        );
        if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        } else {
          resetForm();
        }
      } else {
        const res = await create8(
          {
            model,
            params
          },
          transformData(document)
        );
        if ("data" in res && collectionType !== SINGLE_TYPES) {
          navigate(
            {
              pathname: `../${res.data.documentId}`,
              search: rawQuery
            },
            { replace: true, relative: "path" }
          );
        } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        }
      }
    } finally {
      setSubmitting(false);
    }
  }, [
    clone,
    cloneMatch == null ? void 0 : cloneMatch.params.origin,
    collectionType,
    create8,
    document,
    documentId,
    formatMessage3,
    formatValidationErrors,
    isCloning,
    model,
    modified,
    navigate,
    params,
    rawQuery,
    resetForm,
    setErrors,
    setSubmitting,
    toggleNotification,
    update,
    validate
  ]);
  React11.useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        handleUpdate();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleUpdate]);
  return {
    /**
     * Disabled when:
     * - the form is submitting
     * - the document is not modified & we're not cloning (you can save a clone entity straight away)
     * - the active tab is the published tab
     */
    disabled: isSubmitting || !modified && !isCloning || activeTab === "published",
    label: formatMessage3({
      id: "global.save",
      defaultMessage: "Save"
    }),
    onClick: handleUpdate
  };
};
UpdateAction.type = "update";
UpdateAction.position = "panel";
var UNPUBLISH_DRAFT_OPTIONS = {
  KEEP: "keep",
  DISCARD: "discard"
};
var UnpublishAction$1 = ({
  activeTab,
  documentId,
  model,
  collectionType,
  document
}) => {
  var _a;
  const { formatMessage: formatMessage3 } = useIntl();
  const { schema } = useDoc();
  const canPublish = useDocumentRBAC("UnpublishAction", ({ canPublish: canPublish2 }) => canPublish2);
  const { unpublish } = useDocumentActions();
  const [{ query }] = useQueryParams();
  const params = React11.useMemo(() => buildValidParams(query), [query]);
  const { toggleNotification } = useNotification();
  const [shouldKeepDraft, setShouldKeepDraft] = React11.useState(true);
  const isDocumentModified = (document == null ? void 0 : document.status) === "modified";
  const handleChange = (value) => {
    setShouldKeepDraft(value === UNPUBLISH_DRAFT_OPTIONS.KEEP);
  };
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  return {
    disabled: !canPublish || activeTab === "published" || (document == null ? void 0 : document.status) !== "published" && (document == null ? void 0 : document.status) !== "modified",
    label: formatMessage3({
      id: "app.utils.unpublish",
      defaultMessage: "Unpublish"
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$3$, {}),
    onClick: async () => {
      if (!documentId && collectionType !== SINGLE_TYPES || isDocumentModified) {
        if (!documentId) {
          console.error(
            "You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue."
          );
          toggleNotification({
            message: formatMessage3({
              id: "content-manager.actions.unpublish.error",
              defaultMessage: "An error occurred while trying to unpublish the document."
            }),
            type: "danger"
          });
        }
        return;
      }
      await unpublish({
        collectionType,
        model,
        documentId,
        params
      });
    },
    dialog: isDocumentModified ? {
      type: "dialog",
      title: formatMessage3({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, { alignItems: "flex-start", direction: "column", gap: 6, children: [
        (0, import_jsx_runtime.jsxs)(Flex, { width: "100%", direction: "column", gap: 2, children: [
          (0, import_jsx_runtime.jsx)(ForwardRef$3, { width: "24px", height: "24px", fill: "danger600" }),
          (0, import_jsx_runtime.jsx)(Typography, { tag: "p", variant: "omega", textAlign: "center", children: formatMessage3({
            id: "content-manager.actions.unpublish.dialog.body",
            defaultMessage: "Are you sure?"
          }) })
        ] }),
        (0, import_jsx_runtime.jsxs)(
          Radio.Group,
          {
            defaultValue: UNPUBLISH_DRAFT_OPTIONS.KEEP,
            name: "discard-options",
            "aria-label": formatMessage3({
              id: "content-manager.actions.unpublish.dialog.radio-label",
              defaultMessage: "Choose an option to unpublish the document."
            }),
            onValueChange: handleChange,
            children: [
              (0, import_jsx_runtime.jsx)(Radio.Item, { checked: shouldKeepDraft, value: UNPUBLISH_DRAFT_OPTIONS.KEEP, children: formatMessage3({
                id: "content-manager.actions.unpublish.dialog.option.keep-draft",
                defaultMessage: "Keep draft"
              }) }),
              (0, import_jsx_runtime.jsx)(Radio.Item, { checked: !shouldKeepDraft, value: UNPUBLISH_DRAFT_OPTIONS.DISCARD, children: formatMessage3({
                id: "content-manager.actions.unpublish.dialog.option.replace-draft",
                defaultMessage: "Replace draft"
              }) })
            ]
          }
        )
      ] }),
      onConfirm: async () => {
        if (!documentId && collectionType !== SINGLE_TYPES) {
          console.error(
            "You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue."
          );
          toggleNotification({
            message: formatMessage3({
              id: "content-manager.actions.unpublish.error",
              defaultMessage: "An error occurred while trying to unpublish the document."
            }),
            type: "danger"
          });
        }
        await unpublish(
          {
            collectionType,
            model,
            documentId,
            params
          },
          !shouldKeepDraft
        );
      }
    } : void 0,
    variant: "danger",
    position: ["panel", "table-row"]
  };
};
UnpublishAction$1.type = "unpublish";
UnpublishAction$1.position = "panel";
var DiscardAction = ({
  activeTab,
  documentId,
  model,
  collectionType,
  document
}) => {
  var _a;
  const { formatMessage: formatMessage3 } = useIntl();
  const { schema } = useDoc();
  const canUpdate = useDocumentRBAC("DiscardAction", ({ canUpdate: canUpdate2 }) => canUpdate2);
  const { discard } = useDocumentActions();
  const [{ query }] = useQueryParams();
  const params = React11.useMemo(() => buildValidParams(query), [query]);
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  return {
    disabled: !canUpdate || activeTab === "published" || (document == null ? void 0 : document.status) !== "modified",
    label: formatMessage3({
      id: "content-manager.actions.discard.label",
      defaultMessage: "Discard changes"
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$3$, {}),
    position: ["panel", "table-row"],
    variant: "danger",
    dialog: {
      type: "dialog",
      title: formatMessage3({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 2, children: [
        (0, import_jsx_runtime.jsx)(ForwardRef$3, { width: "24px", height: "24px", fill: "danger600" }),
        (0, import_jsx_runtime.jsx)(Typography, { tag: "p", variant: "omega", textAlign: "center", children: formatMessage3({
          id: "content-manager.actions.discard.dialog.body",
          defaultMessage: "Are you sure?"
        }) })
      ] }),
      onConfirm: async () => {
        await discard({
          collectionType,
          model,
          documentId,
          params
        });
      }
    }
  };
};
DiscardAction.type = "discard";
DiscardAction.position = "panel";
var DEFAULT_ACTIONS = [PublishAction$1, UpdateAction, UnpublishAction$1, DiscardAction];
var intervals = ["years", "months", "days", "hours", "minutes", "seconds"];
var RelativeTime = React11.forwardRef(
  ({ timestamp, customIntervals = [], ...restProps }, forwardedRef) => {
    const { formatRelativeTime: formatRelativeTime2, formatDate: formatDate2, formatTime: formatTime2 } = useIntl();
    const interval = intervalToDuration({
      start: timestamp,
      end: Date.now()
      // see https://github.com/date-fns/date-fns/issues/2891  No idea why it's all partial it returns it every time.
    });
    const unit = intervals.find((intervalUnit) => {
      return interval[intervalUnit] > 0 && Object.keys(interval).includes(intervalUnit);
    }) ?? "seconds";
    const relativeTime = isPast(timestamp) ? -interval[unit] : interval[unit];
    const customInterval = customIntervals.find(
      (custom) => interval[custom.unit] < custom.threshold
    );
    const displayText = customInterval ? customInterval.text : formatRelativeTime2(relativeTime, unit, { numeric: "auto" });
    return (0, import_jsx_runtime.jsx)(
      "time",
      {
        ref: forwardedRef,
        dateTime: timestamp.toISOString(),
        role: "time",
        title: `${formatDate2(timestamp)} ${formatTime2(timestamp)}`,
        ...restProps,
        children: displayText
      }
    );
  }
);
var getDisplayName = ({
  firstname,
  lastname,
  username,
  email
} = {}) => {
  if (username) {
    return username;
  }
  if (firstname) {
    return `${firstname} ${lastname ?? ""}`.trim();
  }
  return email ?? "";
};
var capitalise = (str) => str.charAt(0).toUpperCase() + str.slice(1);
var DocumentStatus = ({ status = "draft", size = "S", ...restProps }) => {
  const statusVariant = status === "draft" ? "secondary" : status === "published" ? "success" : "alternative";
  const { formatMessage: formatMessage3 } = useIntl();
  return (0, import_jsx_runtime.jsx)(Status, { ...restProps, size, variant: statusVariant, children: (0, import_jsx_runtime.jsx)(Typography, { tag: "span", variant: "omega", fontWeight: "bold", children: formatMessage3({
    id: `content-manager.containers.List.${status}`,
    defaultMessage: capitalise(status)
  }) }) });
};
var Header = ({ isCreating, status, title: documentTitle = "Untitled" }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const isCloning = useMatch(CLONE_PATH) !== null;
  const params = useParams();
  const title = isCreating ? formatMessage3({
    id: "content-manager.containers.edit.title.new",
    defaultMessage: "Create an entry"
  }) : documentTitle;
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "flex-start", paddingTop: 6, paddingBottom: 4, gap: 2, children: [
    (0, import_jsx_runtime.jsx)(
      BackButton,
      {
        fallback: params.collectionType === SINGLE_TYPES ? void 0 : `../${COLLECTION_TYPES}/${params.slug}`
      }
    ),
    (0, import_jsx_runtime.jsxs)(Flex, { width: "100%", justifyContent: "space-between", gap: "80px", alignItems: "flex-start", children: [
      (0, import_jsx_runtime.jsx)(Typography, { variant: "alpha", tag: "h1", children: title }),
      (0, import_jsx_runtime.jsx)(HeaderToolbar, {})
    ] }),
    status ? (0, import_jsx_runtime.jsx)(Box, { marginTop: 1, children: (0, import_jsx_runtime.jsx)(DocumentStatus, { status: isCloning ? "draft" : status }) }) : null
  ] });
};
var HeaderToolbar = () => {
  const { formatMessage: formatMessage3 } = useIntl();
  const isCloning = useMatch(CLONE_PATH) !== null;
  const [
    {
      query: { status = "draft" }
    }
  ] = useQueryParams();
  const { model, id, document, meta, collectionType } = useDoc();
  const plugins = useStrapiApp("HeaderToolbar", (state) => state.plugins);
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
    (0, import_jsx_runtime.jsx)(
      DescriptionComponentRenderer,
      {
        props: {
          activeTab: status,
          model,
          documentId: id,
          document: isCloning ? void 0 : document,
          meta: isCloning ? void 0 : meta,
          collectionType
        },
        descriptions: plugins["content-manager"].apis.getHeaderActions(),
        children: (actions2) => {
          if (actions2.length > 0) {
            return (0, import_jsx_runtime.jsx)(HeaderActions, { actions: actions2 });
          } else {
            return null;
          }
        }
      }
    ),
    (0, import_jsx_runtime.jsx)(
      DescriptionComponentRenderer,
      {
        props: {
          activeTab: status,
          model,
          documentId: id,
          document: isCloning ? void 0 : document,
          meta: isCloning ? void 0 : meta,
          collectionType
        },
        descriptions: plugins["content-manager"].apis.getDocumentActions("header"),
        children: (actions2) => {
          const headerActions = actions2.filter((action) => {
            const positions = Array.isArray(action.position) ? action.position : [action.position];
            return positions.includes("header");
          });
          return (0, import_jsx_runtime.jsx)(
            DocumentActionsMenu,
            {
              actions: headerActions,
              label: formatMessage3({
                id: "content-manager.containers.edit.header.more-actions",
                defaultMessage: "More actions"
              }),
              children: (0, import_jsx_runtime.jsx)(Information, { activeTab: status })
            }
          );
        }
      }
    )
  ] });
};
var Information = ({ activeTab }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const { document, meta } = useDoc();
  if (!document || !document.id) {
    return null;
  }
  const createAndUpdateDocument = activeTab === "draft" ? document : meta == null ? void 0 : meta.availableStatus.find((status) => status.publishedAt === null);
  const publishDocument = activeTab === "published" ? document : meta == null ? void 0 : meta.availableStatus.find((status) => status.publishedAt !== null);
  const creator = (createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[CREATED_BY_ATTRIBUTE_NAME]) ? getDisplayName(createAndUpdateDocument[CREATED_BY_ATTRIBUTE_NAME]) : null;
  const updator = (createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[UPDATED_BY_ATTRIBUTE_NAME]) ? getDisplayName(createAndUpdateDocument[UPDATED_BY_ATTRIBUTE_NAME]) : null;
  const information = [
    {
      isDisplayed: !!(publishDocument == null ? void 0 : publishDocument[PUBLISHED_AT_ATTRIBUTE_NAME]),
      label: formatMessage3({
        id: "content-manager.containers.edit.information.last-published.label",
        defaultMessage: "Published"
      }),
      value: formatMessage3(
        {
          id: "content-manager.containers.edit.information.last-published.value",
          defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
        },
        {
          time: (0, import_jsx_runtime.jsx)(RelativeTime, { timestamp: new Date(publishDocument == null ? void 0 : publishDocument[PUBLISHED_AT_ATTRIBUTE_NAME]) }),
          isAnonymous: !(publishDocument == null ? void 0 : publishDocument[PUBLISHED_BY_ATTRIBUTE_NAME]),
          author: (publishDocument == null ? void 0 : publishDocument[PUBLISHED_BY_ATTRIBUTE_NAME]) ? getDisplayName(publishDocument == null ? void 0 : publishDocument[PUBLISHED_BY_ATTRIBUTE_NAME]) : null
        }
      )
    },
    {
      isDisplayed: !!(createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[UPDATED_AT_ATTRIBUTE_NAME]),
      label: formatMessage3({
        id: "content-manager.containers.edit.information.last-draft.label",
        defaultMessage: "Updated"
      }),
      value: formatMessage3(
        {
          id: "content-manager.containers.edit.information.last-draft.value",
          defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
        },
        {
          time: (0, import_jsx_runtime.jsx)(
            RelativeTime,
            {
              timestamp: new Date(createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[UPDATED_AT_ATTRIBUTE_NAME])
            }
          ),
          isAnonymous: !updator,
          author: updator
        }
      )
    },
    {
      isDisplayed: !!(createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[CREATED_AT_ATTRIBUTE_NAME]),
      label: formatMessage3({
        id: "content-manager.containers.edit.information.document.label",
        defaultMessage: "Created"
      }),
      value: formatMessage3(
        {
          id: "content-manager.containers.edit.information.document.value",
          defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
        },
        {
          time: (0, import_jsx_runtime.jsx)(
            RelativeTime,
            {
              timestamp: new Date(createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[CREATED_AT_ATTRIBUTE_NAME])
            }
          ),
          isAnonymous: !creator,
          author: creator
        }
      )
    }
  ].filter((info) => info.isDisplayed);
  return (0, import_jsx_runtime.jsx)(
    Flex,
    {
      borderWidth: "1px 0 0 0",
      borderStyle: "solid",
      borderColor: "neutral150",
      direction: "column",
      marginTop: 2,
      tag: "dl",
      padding: 5,
      gap: 3,
      alignItems: "flex-start",
      marginLeft: "-0.4rem",
      marginRight: "-0.4rem",
      width: "calc(100% + 8px)",
      children: information.map((info) => (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, direction: "column", alignItems: "flex-start", children: [
        (0, import_jsx_runtime.jsx)(Typography, { tag: "dt", variant: "pi", fontWeight: "bold", children: info.label }),
        (0, import_jsx_runtime.jsx)(Typography, { tag: "dd", variant: "pi", textColor: "neutral600", children: info.value })
      ] }, info.label))
    }
  );
};
var HeaderActions = ({ actions: actions2 }) => {
  const [dialogId, setDialogId] = React11.useState(null);
  const handleClick = (action) => async (e) => {
    if (!("options" in action)) {
      const { onClick = () => false, dialog, id } = action;
      const muteDialog = await onClick(e);
      if (dialog && !muteDialog) {
        e.preventDefault();
        setDialogId(id);
      }
    }
  };
  const handleClose = () => {
    setDialogId(null);
  };
  return (0, import_jsx_runtime.jsx)(Flex, { gap: 1, children: actions2.map((action) => {
    if (action.options) {
      return (0, import_jsx_runtime.jsx)(
        SingleSelect,
        {
          size: "S",
          onChange: action.onSelect,
          "aria-label": action.label,
          ...action,
          children: action.options.map(({ label, ...option }) => (0, import_jsx_runtime.jsx)(SingleSelectOption, { ...option, children: label }, option.value))
        },
        action.id
      );
    } else {
      if (action.type === "icon") {
        return (0, import_jsx_runtime.jsxs)(React11.Fragment, { children: [
          (0, import_jsx_runtime.jsx)(
            IconButton,
            {
              disabled: action.disabled,
              label: action.label,
              size: "S",
              onClick: handleClick(action),
              children: action.icon
            }
          ),
          action.dialog ? (0, import_jsx_runtime.jsx)(
            HeaderActionDialog,
            {
              ...action.dialog,
              isOpen: dialogId === action.id,
              onClose: handleClose
            }
          ) : null
        ] }, action.id);
      }
    }
  }) });
};
var HeaderActionDialog = ({
  onClose,
  onCancel,
  title,
  content: Content,
  isOpen
}) => {
  const handleClose = async () => {
    if (onCancel) {
      await onCancel();
    }
    onClose();
  };
  return (0, import_jsx_runtime.jsx)(Dialog.Root, { open: isOpen, onOpenChange: handleClose, children: (0, import_jsx_runtime.jsxs)(Dialog.Content, { children: [
    (0, import_jsx_runtime.jsx)(Dialog.Header, { children: title }),
    typeof Content === "function" ? (0, import_jsx_runtime.jsx)(Content, { onClose: handleClose }) : Content
  ] }) });
};
var ConfigureTheViewAction = ({ collectionType, model }) => {
  const navigate = useNavigate();
  const { formatMessage: formatMessage3 } = useIntl();
  return {
    label: formatMessage3({
      id: "app.links.configure-view",
      defaultMessage: "Configure the view"
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$2h, {}),
    onClick: () => {
      navigate(`../${collectionType}/${model}/configurations/edit`);
    },
    position: "header"
  };
};
ConfigureTheViewAction.type = "configure-the-view";
ConfigureTheViewAction.position = "header";
var EditTheModelAction = ({ model }) => {
  const navigate = useNavigate();
  const { formatMessage: formatMessage3 } = useIntl();
  return {
    label: formatMessage3({
      id: "content-manager.link-to-ctb",
      defaultMessage: "Edit the model"
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$1r, {}),
    onClick: () => {
      navigate(`/plugins/content-type-builder/content-types/${model}`);
    },
    position: "header"
  };
};
EditTheModelAction.type = "edit-the-model";
EditTheModelAction.position = "header";
var DeleteAction$1 = ({ documentId, model, collectionType, document }) => {
  const navigate = useNavigate();
  const { formatMessage: formatMessage3 } = useIntl();
  const listViewPathMatch = useMatch(LIST_PATH);
  const canDelete = useDocumentRBAC("DeleteAction", (state) => state.canDelete);
  const { delete: deleteAction } = useDocumentActions();
  const { toggleNotification } = useNotification();
  const setSubmitting = useForm("DeleteAction", (state) => state.setSubmitting);
  const isLocalized = (document == null ? void 0 : document.locale) != null;
  return {
    disabled: !canDelete || !document,
    label: formatMessage3(
      {
        id: "content-manager.actions.delete.label",
        defaultMessage: "Delete entry{isLocalized, select, true { (all locales)} other {}}"
      },
      { isLocalized }
    ),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$j, {}),
    dialog: {
      type: "dialog",
      title: formatMessage3({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 2, children: [
        (0, import_jsx_runtime.jsx)(ForwardRef$3, { width: "24px", height: "24px", fill: "danger600" }),
        (0, import_jsx_runtime.jsx)(Typography, { tag: "p", variant: "omega", textAlign: "center", children: formatMessage3({
          id: "content-manager.actions.delete.dialog.body",
          defaultMessage: "Are you sure?"
        }) })
      ] }),
      onConfirm: async () => {
        if (!listViewPathMatch) {
          setSubmitting(true);
        }
        try {
          if (!documentId && collectionType !== SINGLE_TYPES) {
            console.error(
              "You're trying to delete a document without an id, this is likely a bug with Strapi. Please open an issue."
            );
            toggleNotification({
              message: formatMessage3({
                id: "content-manager.actions.delete.error",
                defaultMessage: "An error occurred while trying to delete the document."
              }),
              type: "danger"
            });
            return;
          }
          const res = await deleteAction({
            documentId,
            model,
            collectionType,
            params: {
              locale: "*"
            }
          });
          if (!("error" in res)) {
            navigate({ pathname: `../${collectionType}/${model}` }, { replace: true });
          }
        } finally {
          if (!listViewPathMatch) {
            setSubmitting(false);
          }
        }
      }
    },
    variant: "danger",
    position: ["header", "table-row"]
  };
};
DeleteAction$1.type = "delete";
DeleteAction$1.position = ["header", "table-row"];
var DEFAULT_HEADER_ACTIONS = [EditTheModelAction, ConfigureTheViewAction, DeleteAction$1];
var Panels = () => {
  const isCloning = useMatch(CLONE_PATH) !== null;
  const [
    {
      query: { status }
    }
  ] = useQueryParams({
    status: "draft"
  });
  const { model, id, document, meta, collectionType } = useDoc();
  const plugins = useStrapiApp("Panels", (state) => state.plugins);
  const props = {
    activeTab: status,
    model,
    documentId: id,
    document: isCloning ? void 0 : document,
    meta: isCloning ? void 0 : meta,
    collectionType
  };
  return (0, import_jsx_runtime.jsx)(Flex, { direction: "column", alignItems: "stretch", gap: 2, children: (0, import_jsx_runtime.jsx)(
    DescriptionComponentRenderer,
    {
      props,
      descriptions: plugins["content-manager"].apis.getEditViewSidePanels(),
      children: (panels) => panels.map(({ content, id: id2, ...description }) => (0, import_jsx_runtime.jsx)(Panel, { ...description, children: content }, id2))
    }
  ) });
};
var ActionsPanel = () => {
  const { formatMessage: formatMessage3 } = useIntl();
  return {
    title: formatMessage3({
      id: "content-manager.containers.edit.panels.default.title",
      defaultMessage: "Entry"
    }),
    content: (0, import_jsx_runtime.jsx)(ActionsPanelContent, {})
  };
};
ActionsPanel.type = "actions";
var ActionsPanelContent = () => {
  const isCloning = useMatch(CLONE_PATH) !== null;
  const [
    {
      query: { status = "draft" }
    }
  ] = useQueryParams();
  const { model, id, document, meta, collectionType } = useDoc();
  const plugins = useStrapiApp("ActionsPanel", (state) => state.plugins);
  const props = {
    activeTab: status,
    model,
    documentId: id,
    document: isCloning ? void 0 : document,
    meta: isCloning ? void 0 : meta,
    collectionType
  };
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 2, width: "100%", children: [
    (0, import_jsx_runtime.jsx)(
      DescriptionComponentRenderer,
      {
        props,
        descriptions: plugins["content-manager"].apis.getDocumentActions("panel"),
        children: (actions2) => (0, import_jsx_runtime.jsx)(DocumentActions, { actions: actions2 })
      }
    ),
    (0, import_jsx_runtime.jsx)(InjectionZone, { area: "editView.right-links", slug: model })
  ] });
};
var Panel = React11.forwardRef(({ children, title }, ref) => {
  return (0, import_jsx_runtime.jsxs)(
    Flex,
    {
      ref,
      tag: "aside",
      "aria-labelledby": "additional-information",
      background: "neutral0",
      borderColor: "neutral150",
      hasRadius: true,
      paddingBottom: 4,
      paddingLeft: 4,
      paddingRight: 4,
      paddingTop: 4,
      shadow: "tableShadow",
      gap: 3,
      direction: "column",
      justifyContent: "stretch",
      alignItems: "flex-start",
      children: [
        (0, import_jsx_runtime.jsx)(Typography, { tag: "h2", variant: "sigma", textTransform: "uppercase", textColor: "neutral600", children: title }),
        children
      ]
    }
  );
});
var ConfirmBulkActionDialog = ({
  onToggleDialog,
  isOpen = false,
  dialogBody,
  endAction
}) => {
  const { formatMessage: formatMessage3 } = useIntl();
  return (0, import_jsx_runtime.jsx)(Dialog.Root, { open: isOpen, children: (0, import_jsx_runtime.jsxs)(Dialog.Content, { children: [
    (0, import_jsx_runtime.jsx)(Dialog.Header, { children: formatMessage3({
      id: "app.components.ConfirmDialog.title",
      defaultMessage: "Confirmation"
    }) }),
    (0, import_jsx_runtime.jsx)(Dialog.Body, { children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "stretch", gap: 2, children: [
      (0, import_jsx_runtime.jsx)(Flex, { justifyContent: "center", children: (0, import_jsx_runtime.jsx)(ForwardRef$3, { width: "24px", height: "24px", fill: "danger600" }) }),
      dialogBody
    ] }) }),
    (0, import_jsx_runtime.jsxs)(Dialog.Footer, { children: [
      (0, import_jsx_runtime.jsx)(Dialog.Cancel, { children: (0, import_jsx_runtime.jsx)(Button, { fullWidth: true, onClick: onToggleDialog, variant: "tertiary", children: formatMessage3({
        id: "app.components.Button.cancel",
        defaultMessage: "Cancel"
      }) }) }),
      endAction
    ] })
  ] }) });
};
var BoldChunk = (chunks) => (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", children: chunks });
var ConfirmDialogPublishAll = ({
  isOpen,
  onToggleDialog,
  isConfirmButtonLoading = false,
  onConfirm
}) => {
  var _a, _b;
  const { formatMessage: formatMessage3 } = useIntl();
  const selectedEntries = useTable("ConfirmDialogPublishAll", (state) => state.selectedRows);
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler(getTranslation);
  const { model, schema } = useDoc();
  const [{ query }] = useQueryParams();
  const enableDraftRelationsCount = false;
  const {
    data: countDraftRelations = 0,
    isLoading,
    error
  } = useGetManyDraftRelationCountQuery(
    {
      model,
      documentIds: selectedEntries.map((entry) => entry.documentId),
      locale: (_b = (_a = query == null ? void 0 : query.plugins) == null ? void 0 : _a.i18n) == null ? void 0 : _b.locale
    },
    {
      skip: !enableDraftRelationsCount
    }
  );
  React11.useEffect(() => {
    if (error) {
      toggleNotification({ type: "danger", message: formatAPIError(error) });
    }
  }, [error, formatAPIError, toggleNotification]);
  if (error) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(
    ConfirmBulkActionDialog,
    {
      isOpen: isOpen && !isLoading,
      onToggleDialog,
      dialogBody: (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        (0, import_jsx_runtime.jsxs)(Typography, { id: "confirm-description", textAlign: "center", children: [
          countDraftRelations > 0 && formatMessage3(
            {
              id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
              defaultMessage: "<b>{count} {count, plural, one { relation } other { relations } } out of {entities} { entities, plural, one { entry } other { entries } } {count, plural, one { is } other { are } }</b> not published yet and might lead to unexpected behavior. "
            },
            {
              b: BoldChunk,
              count: countDraftRelations,
              entities: selectedEntries.length
            }
          ),
          formatMessage3({
            id: getTranslation("popUpWarning.bodyMessage.contentType.publish.all"),
            defaultMessage: "Are you sure you want to publish these entries?"
          })
        ] }),
        (schema == null ? void 0 : schema.pluginOptions) && "i18n" in schema.pluginOptions && (schema == null ? void 0 : schema.pluginOptions.i18n) && (0, import_jsx_runtime.jsx)(Typography, { textColor: "danger500", textAlign: "center", children: formatMessage3(
          {
            id: getTranslation("Settings.list.actions.publishAdditionalInfos"),
            defaultMessage: "This will publish the active locale versions <em>(from Internationalization)</em>"
          },
          {
            em: Emphasis
          }
        ) })
      ] }),
      endAction: (0, import_jsx_runtime.jsx)(
        Button,
        {
          onClick: onConfirm,
          variant: "secondary",
          startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$4x, {}),
          loading: isConfirmButtonLoading,
          children: formatMessage3({
            id: "app.utils.publish",
            defaultMessage: "Publish"
          })
        }
      )
    }
  );
};
var TypographyMaxWidth = dt(Typography)`
  max-width: 300px;
`;
var TableComponent = dt(RawTable)`
  width: 100%;
  table-layout: fixed;
  td:first-child {
    border-right: 1px solid ${({ theme }) => theme.colors.neutral150};
  }
  td:first-of-type {
    padding: ${({ theme }) => theme.spaces[4]};
  }
`;
var formatErrorMessages = (errors, parentKey, formatMessage3) => {
  const messages = [];
  Object.entries(errors).forEach(([key, value]) => {
    const currentKey = parentKey ? `${parentKey}.${key}` : key;
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      if ("id" in value && "defaultMessage" in value) {
        messages.push(
          formatMessage3(
            {
              id: `${value.id}.withField`,
              defaultMessage: value.defaultMessage
            },
            { field: currentKey }
          )
        );
      } else {
        messages.push(
          ...formatErrorMessages(
            // @ts-expect-error TODO: check why value is not compatible with FormErrors
            value,
            currentKey,
            formatMessage3
          )
        );
      }
    } else {
      messages.push(
        formatMessage3(
          {
            id: `${value}.withField`,
            defaultMessage: value
          },
          { field: currentKey }
        )
      );
    }
  });
  return messages;
};
var EntryValidationText = ({ validationErrors, status }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  if (validationErrors) {
    const validationErrorsMessages = formatErrorMessages(validationErrors, "", formatMessage3).join(
      " "
    );
    return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$3Z, { fill: "danger600" }),
      (0, import_jsx_runtime.jsx)(TooltipImpl, { description: validationErrorsMessages, children: (0, import_jsx_runtime.jsx)(TypographyMaxWidth, { textColor: "danger600", variant: "omega", fontWeight: "semiBold", ellipsis: true, children: validationErrorsMessages }) })
    ] });
  }
  if (status === "published") {
    return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$4v, { fill: "success600" }),
      (0, import_jsx_runtime.jsx)(Typography, { textColor: "success600", fontWeight: "bold", children: formatMessage3({
        id: "content-manager.bulk-publish.already-published",
        defaultMessage: "Already Published"
      }) })
    ] });
  }
  if (status === "modified") {
    return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$4$, { fill: "alternative600" }),
      (0, import_jsx_runtime.jsx)(Typography, { children: formatMessage3({
        id: "content-manager.bulk-publish.modified",
        defaultMessage: "Ready to publish changes"
      }) })
    ] });
  }
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
    (0, import_jsx_runtime.jsx)(ForwardRef$4v, { fill: "success600" }),
    (0, import_jsx_runtime.jsx)(Typography, { children: formatMessage3({
      id: "app.utils.ready-to-publish",
      defaultMessage: "Ready to publish"
    }) })
  ] });
};
var TABLE_HEADERS = [
  { name: "id", label: "id" },
  { name: "name", label: "name" },
  { name: "status", label: "status" },
  { name: "publicationStatus", label: "Publication status" }
];
var SelectedEntriesTableContent = ({
  isPublishing,
  rowsToDisplay = [],
  entriesToPublish = [],
  validationErrors = {}
}) => {
  const { pathname } = useLocation();
  const { formatMessage: formatMessage3 } = useIntl();
  const {
    list: {
      settings: { mainField }
    }
  } = useDocLayout();
  const shouldDisplayMainField = mainField != null && mainField !== "id";
  return (0, import_jsx_runtime.jsxs)(Table.Content, { children: [
    (0, import_jsx_runtime.jsxs)(Table.Head, { children: [
      (0, import_jsx_runtime.jsx)(Table.HeaderCheckboxCell, {}),
      TABLE_HEADERS.filter((head) => head.name !== "name" || shouldDisplayMainField).map(
        (head) => (0, import_jsx_runtime.jsx)(Table.HeaderCell, { ...head }, head.name)
      )
    ] }),
    (0, import_jsx_runtime.jsx)(Table.Loading, {}),
    (0, import_jsx_runtime.jsx)(Table.Body, { children: rowsToDisplay.map((row) => (0, import_jsx_runtime.jsxs)(Table.Row, { children: [
      (0, import_jsx_runtime.jsx)(Table.CheckboxCell, { id: row.id }),
      (0, import_jsx_runtime.jsx)(Table.Cell, { children: (0, import_jsx_runtime.jsx)(Typography, { children: row.id }) }),
      shouldDisplayMainField && (0, import_jsx_runtime.jsx)(Table.Cell, { children: (0, import_jsx_runtime.jsx)(Typography, { children: row[mainField] }) }),
      (0, import_jsx_runtime.jsx)(Table.Cell, { children: (0, import_jsx_runtime.jsx)(DocumentStatus, { status: row.status, maxWidth: "min-content" }) }),
      (0, import_jsx_runtime.jsx)(Table.Cell, { children: isPublishing && entriesToPublish.includes(row.documentId) ? (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
        (0, import_jsx_runtime.jsx)(Typography, { children: formatMessage3({
          id: "content-manager.success.record.publishing",
          defaultMessage: "Publishing..."
        }) }),
        (0, import_jsx_runtime.jsx)(Loader, { small: true })
      ] }) : (0, import_jsx_runtime.jsx)(
        EntryValidationText,
        {
          validationErrors: validationErrors[row.documentId],
          status: row.status
        }
      ) }),
      (0, import_jsx_runtime.jsx)(Table.Cell, { children: (0, import_jsx_runtime.jsx)(Flex, { children: (0, import_jsx_runtime.jsx)(
        IconButton,
        {
          tag: Link,
          to: {
            pathname: `${pathname}/${row.documentId}`,
            search: row.locale && `?plugins[i18n][locale]=${row.locale}`
          },
          state: { from: pathname },
          label: formatMessage3({
            id: "content-manager.bulk-publish.edit",
            defaultMessage: "Edit"
          }),
          target: "_blank",
          marginLeft: "auto",
          variant: "ghost",
          children: (0, import_jsx_runtime.jsx)(ForwardRef$1r, { width: "1.6rem", height: "1.6rem" })
        }
      ) }) })
    ] }, row.id)) })
  ] });
};
var PublicationStatusSummary = ({ count, icon, message }) => {
  return (0, import_jsx_runtime.jsxs)(Flex, { justifyContent: "space-between", flex: 1, gap: 3, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      icon,
      (0, import_jsx_runtime.jsx)(Typography, { children: message })
    ] }),
    (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "bold", children: count })
  ] });
};
var PublicationStatusGrid = ({
  entriesReadyToPublishCount,
  entriesPublishedCount,
  entriesModifiedCount,
  entriesWithErrorsCount
}) => {
  const { formatMessage: formatMessage3 } = useIntl();
  return (0, import_jsx_runtime.jsx)(Box, { hasRadius: true, borderColor: "neutral150", children: (0, import_jsx_runtime.jsx)(TableComponent, { colCount: 2, rowCount: 2, children: (0, import_jsx_runtime.jsxs)(Tbody, { children: [
    (0, import_jsx_runtime.jsxs)(Tr, { children: [
      (0, import_jsx_runtime.jsx)(Td, { children: (0, import_jsx_runtime.jsx)(
        PublicationStatusSummary,
        {
          count: entriesReadyToPublishCount,
          icon: (0, import_jsx_runtime.jsx)(ForwardRef$4v, { fill: "success600" }),
          message: formatMessage3({
            id: "app.utils.ready-to-publish",
            defaultMessage: "Ready to publish"
          })
        }
      ) }),
      (0, import_jsx_runtime.jsx)(Td, { children: (0, import_jsx_runtime.jsx)(
        PublicationStatusSummary,
        {
          count: entriesPublishedCount,
          icon: (0, import_jsx_runtime.jsx)(ForwardRef$4v, { fill: "success600" }),
          message: formatMessage3({
            id: "app.utils.already-published",
            defaultMessage: "Already published"
          })
        }
      ) })
    ] }),
    (0, import_jsx_runtime.jsxs)(Tr, { children: [
      (0, import_jsx_runtime.jsx)(Td, { children: (0, import_jsx_runtime.jsx)(
        PublicationStatusSummary,
        {
          count: entriesModifiedCount,
          icon: (0, import_jsx_runtime.jsx)(ForwardRef$4$, { fill: "alternative600" }),
          message: formatMessage3({
            id: "content-manager.bulk-publish.modified",
            defaultMessage: "Ready to publish changes"
          })
        }
      ) }),
      (0, import_jsx_runtime.jsx)(Td, { children: (0, import_jsx_runtime.jsx)(
        PublicationStatusSummary,
        {
          count: entriesWithErrorsCount,
          icon: (0, import_jsx_runtime.jsx)(ForwardRef$3Z, { fill: "danger600" }),
          message: formatMessage3({
            id: "content-manager.bulk-publish.waiting-for-action",
            defaultMessage: "Waiting for action"
          })
        }
      ) })
    ] })
  ] }) }) });
};
var SelectedEntriesModalContent = ({
  listViewSelectedEntries,
  toggleModal,
  setListViewSelectedDocuments,
  model
}) => {
  var _a, _b;
  const { formatMessage: formatMessage3 } = useIntl();
  const { schema, components } = useContentTypeSchema(model);
  const documentIds = listViewSelectedEntries.map(({ documentId }) => documentId);
  const [{ query }] = useQueryParams();
  const params = React11.useMemo(() => buildValidParams(query), [query]);
  const { data, isLoading, isFetching, refetch } = useGetAllDocumentsQuery(
    {
      model,
      params: {
        page: "1",
        pageSize: documentIds.length.toString(),
        sort: query.sort,
        filters: {
          documentId: {
            $in: documentIds
          }
        },
        locale: (_b = (_a = query.plugins) == null ? void 0 : _a.i18n) == null ? void 0 : _b.locale
      }
    },
    {
      selectFromResult: ({ data: data2, ...restRes }) => ({ data: (data2 == null ? void 0 : data2.results) ?? [], ...restRes })
    }
  );
  const { rows, validationErrors } = React11.useMemo(() => {
    if (data.length > 0 && schema) {
      const validate = createYupSchema(
        schema.attributes,
        components,
        // Since this is the "Publish" action, the validation
        // schema must enforce the rules for published entities
        { status: "published" }
      );
      const validationErrors2 = {};
      const rows2 = data.map((entry) => {
        try {
          validate.validateSync(entry, { abortEarly: false });
          return entry;
        } catch (e) {
          if (e instanceof ValidationError) {
            validationErrors2[entry.documentId] = getYupValidationErrors(e);
          }
          return entry;
        }
      });
      return { rows: rows2, validationErrors: validationErrors2 };
    }
    return {
      rows: [],
      validationErrors: {}
    };
  }, [components, data, schema]);
  const [isDialogOpen, setIsDialogOpen] = React11.useState(false);
  const { publishMany: bulkPublishAction } = useDocumentActions();
  const [, { isLoading: isSubmittingForm }] = usePublishManyDocumentsMutation();
  const selectedRows = useTable("publishAction", (state) => state.selectedRows);
  const selectedEntries = rows.filter(
    (entry) => selectedRows.some((selectedEntry) => selectedEntry.documentId === entry.documentId)
  );
  const entriesToPublish = selectedEntries.filter((entry) => !validationErrors[entry.documentId]).map((entry) => entry.documentId);
  const selectedEntriesWithErrorsCount = selectedEntries.filter(
    ({ documentId }) => validationErrors[documentId]
  ).length;
  const selectedEntriesPublishedCount = selectedEntries.filter(
    ({ status }) => status === "published"
  ).length;
  const selectedEntriesModifiedCount = selectedEntries.filter(
    ({ status, documentId }) => status === "modified" && !validationErrors[documentId]
  ).length;
  const selectedEntriesWithNoErrorsCount = selectedEntries.length - selectedEntriesWithErrorsCount - selectedEntriesPublishedCount;
  const toggleDialog = () => setIsDialogOpen((prev) => !prev);
  const handleConfirmBulkPublish = async () => {
    toggleDialog();
    const res = await bulkPublishAction({ model, documentIds: entriesToPublish, params });
    if (!("error" in res)) {
      const unpublishedEntries = rows.filter((row) => {
        return !entriesToPublish.includes(row.documentId);
      });
      setListViewSelectedDocuments(unpublishedEntries);
    }
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsxs)(Modal.Body, { children: [
      (0, import_jsx_runtime.jsx)(
        PublicationStatusGrid,
        {
          entriesReadyToPublishCount: selectedEntriesWithNoErrorsCount - selectedEntriesModifiedCount,
          entriesPublishedCount: selectedEntriesPublishedCount,
          entriesModifiedCount: selectedEntriesModifiedCount,
          entriesWithErrorsCount: selectedEntriesWithErrorsCount
        }
      ),
      (0, import_jsx_runtime.jsx)(Box, { marginTop: 7, children: (0, import_jsx_runtime.jsx)(
        SelectedEntriesTableContent,
        {
          isPublishing: isSubmittingForm,
          rowsToDisplay: rows,
          entriesToPublish,
          validationErrors
        }
      ) })
    ] }),
    (0, import_jsx_runtime.jsxs)(Modal.Footer, { children: [
      (0, import_jsx_runtime.jsx)(Button, { onClick: toggleModal, variant: "tertiary", children: formatMessage3({
        id: "app.components.Button.cancel",
        defaultMessage: "Cancel"
      }) }),
      (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
        (0, import_jsx_runtime.jsx)(Button, { onClick: refetch, variant: "tertiary", loading: isFetching, children: formatMessage3({ id: "app.utils.refresh", defaultMessage: "Refresh" }) }),
        (0, import_jsx_runtime.jsx)(
          Button,
          {
            onClick: toggleDialog,
            disabled: selectedEntries.length === 0 || selectedEntries.length === selectedEntriesWithErrorsCount || selectedEntriesPublishedCount === selectedEntries.length || isLoading,
            loading: isSubmittingForm,
            children: formatMessage3({ id: "app.utils.publish", defaultMessage: "Publish" })
          }
        )
      ] })
    ] }),
    (0, import_jsx_runtime.jsx)(
      ConfirmDialogPublishAll,
      {
        isOpen: isDialogOpen,
        onToggleDialog: toggleDialog,
        isConfirmButtonLoading: isSubmittingForm,
        onConfirm: handleConfirmBulkPublish
      }
    )
  ] });
};
var PublishAction = ({ documents, model }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const hasPublishPermission = useDocumentRBAC("unpublishAction", (state) => state.canPublish);
  const showPublishButton = hasPublishPermission && documents.some(({ status }) => status !== "published");
  const setListViewSelectedDocuments = useTable("publishAction", (state) => state.selectRow);
  const refetchList = () => {
    contentManagerApi.util.invalidateTags([{ type: "Document", id: `${model}_LIST` }]);
  };
  if (!showPublishButton)
    return null;
  return {
    actionType: "publish",
    variant: "tertiary",
    label: formatMessage3({ id: "app.utils.publish", defaultMessage: "Publish" }),
    dialog: {
      type: "modal",
      title: formatMessage3({
        id: getTranslation("containers.ListPage.selectedEntriesModal.title"),
        defaultMessage: "Publish entries"
      }),
      content: ({ onClose }) => {
        return (0, import_jsx_runtime.jsx)(Table.Root, { rows: documents, defaultSelectedRows: documents, headers: TABLE_HEADERS, children: (0, import_jsx_runtime.jsx)(
          SelectedEntriesModalContent,
          {
            listViewSelectedEntries: documents,
            toggleModal: () => {
              onClose();
              refetchList();
            },
            setListViewSelectedDocuments,
            model
          }
        ) });
      },
      onClose: () => {
        refetchList();
      }
    }
  };
};
var BulkActionsRenderer = () => {
  const plugins = useStrapiApp("BulkActionsRenderer", (state) => state.plugins);
  const { model, collectionType } = useDoc();
  const { selectedRows } = useTable("BulkActionsRenderer", (state) => state);
  return (0, import_jsx_runtime.jsx)(Flex, { gap: 2, children: (0, import_jsx_runtime.jsx)(
    DescriptionComponentRenderer,
    {
      props: {
        model,
        collectionType,
        documents: selectedRows
      },
      descriptions: plugins["content-manager"].apis.getBulkActions(),
      children: (actions2) => actions2.map((action) => (0, import_jsx_runtime.jsx)(DocumentActionButton, { ...action }, action.id))
    }
  ) });
};
var DeleteAction = ({ documents, model }) => {
  var _a;
  const { formatMessage: formatMessage3 } = useIntl();
  const { schema: contentType } = useDoc();
  const selectRow = useTable("DeleteAction", (state) => state.selectRow);
  const hasI18nEnabled = Boolean((_a = contentType == null ? void 0 : contentType.pluginOptions) == null ? void 0 : _a.i18n);
  const [{ query }] = useQueryParams();
  const params = React11.useMemo(() => buildValidParams(query), [query]);
  const hasDeletePermission = useDocumentRBAC("deleteAction", (state) => state.canDelete);
  const { deleteMany: bulkDeleteAction } = useDocumentActions();
  const documentIds = documents.map(({ documentId }) => documentId);
  const handleConfirmBulkDelete = async () => {
    const res = await bulkDeleteAction({
      documentIds,
      model,
      params
    });
    if (!("error" in res)) {
      selectRow([]);
    }
  };
  if (!hasDeletePermission)
    return null;
  return {
    variant: "danger-light",
    label: formatMessage3({ id: "global.delete", defaultMessage: "Delete" }),
    dialog: {
      type: "dialog",
      title: formatMessage3({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "stretch", gap: 2, children: [
        (0, import_jsx_runtime.jsx)(Flex, { justifyContent: "center", children: (0, import_jsx_runtime.jsx)(ForwardRef$3, { width: "24px", height: "24px", fill: "danger600" }) }),
        (0, import_jsx_runtime.jsx)(Typography, { id: "confirm-description", textAlign: "center", children: formatMessage3({
          id: "popUpWarning.bodyMessage.contentType.delete.all",
          defaultMessage: "Are you sure you want to delete these entries?"
        }) }),
        hasI18nEnabled && (0, import_jsx_runtime.jsx)(Box, { textAlign: "center", padding: 3, children: (0, import_jsx_runtime.jsx)(Typography, { textColor: "danger500", children: formatMessage3(
          {
            id: getTranslation("Settings.list.actions.deleteAdditionalInfos"),
            defaultMessage: "This will delete the active locale versions <em>(from Internationalization)</em>"
          },
          {
            em: Emphasis
          }
        ) }) })
      ] }),
      onConfirm: handleConfirmBulkDelete
    }
  };
};
DeleteAction.type = "delete";
var UnpublishAction = ({ documents, model }) => {
  var _a, _b;
  const { formatMessage: formatMessage3 } = useIntl();
  const { schema } = useDoc();
  const selectRow = useTable("UnpublishAction", (state) => state.selectRow);
  const hasPublishPermission = useDocumentRBAC("unpublishAction", (state) => state.canPublish);
  const hasI18nEnabled = Boolean((_a = schema == null ? void 0 : schema.pluginOptions) == null ? void 0 : _a.i18n);
  const hasDraftAndPublishEnabled = Boolean((_b = schema == null ? void 0 : schema.options) == null ? void 0 : _b.draftAndPublish);
  const { unpublishMany: bulkUnpublishAction } = useDocumentActions();
  const documentIds = documents.map(({ documentId }) => documentId);
  const [{ query }] = useQueryParams();
  const params = React11.useMemo(() => buildValidParams(query), [query]);
  const handleConfirmBulkUnpublish = async () => {
    const data = await bulkUnpublishAction({ documentIds, model, params });
    if (!("error" in data)) {
      selectRow([]);
    }
  };
  const showUnpublishButton = hasDraftAndPublishEnabled && hasPublishPermission && documents.some((entry) => entry.status === "published" || entry.status === "modified");
  if (!showUnpublishButton)
    return null;
  return {
    variant: "tertiary",
    label: formatMessage3({ id: "app.utils.unpublish", defaultMessage: "Unpublish" }),
    dialog: {
      type: "dialog",
      title: formatMessage3({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", alignItems: "stretch", gap: 2, children: [
        (0, import_jsx_runtime.jsx)(Flex, { justifyContent: "center", children: (0, import_jsx_runtime.jsx)(ForwardRef$3, { width: "24px", height: "24px", fill: "danger600" }) }),
        (0, import_jsx_runtime.jsx)(Typography, { id: "confirm-description", textAlign: "center", children: formatMessage3({
          id: "popUpWarning.bodyMessage.contentType.unpublish.all",
          defaultMessage: "Are you sure you want to unpublish these entries?"
        }) }),
        hasI18nEnabled && (0, import_jsx_runtime.jsx)(Box, { textAlign: "center", padding: 3, children: (0, import_jsx_runtime.jsx)(Typography, { textColor: "danger500", children: formatMessage3(
          {
            id: getTranslation("Settings.list.actions.unpublishAdditionalInfos"),
            defaultMessage: "This will unpublish the active locale versions <em>(from Internationalization)</em>"
          },
          {
            em: Emphasis
          }
        ) }) })
      ] }),
      confirmButton: formatMessage3({
        id: "app.utils.unpublish",
        defaultMessage: "Unpublish"
      }),
      onConfirm: handleConfirmBulkUnpublish
    }
  };
};
UnpublishAction.type = "unpublish";
var Emphasis = (chunks) => (0, import_jsx_runtime.jsx)(Typography, { fontWeight: "semiBold", textColor: "danger500", children: chunks });
var DEFAULT_BULK_ACTIONS = [PublishAction, UnpublishAction, DeleteAction];
var AutoCloneFailureModalBody = ({ prohibitedFields }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const getDefaultErrorMessage = (reason) => {
    switch (reason) {
      case "relation":
        return "Duplicating the relation could remove it from the original entry.";
      case "unique":
        return "Identical values in a unique field are not allowed";
      default:
        return reason;
    }
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(Typography, { variant: "beta", children: formatMessage3({
      id: getTranslation("containers.list.autoCloneModal.title"),
      defaultMessage: "This entry can't be duplicated directly."
    }) }),
    (0, import_jsx_runtime.jsx)(Box, { marginTop: 2, children: (0, import_jsx_runtime.jsx)(Typography, { textColor: "neutral600", children: formatMessage3({
      id: getTranslation("containers.list.autoCloneModal.description"),
      defaultMessage: "A new entry will be created with the same content, but you'll have to change the following fields to save it."
    }) }) }),
    (0, import_jsx_runtime.jsx)(Flex, { marginTop: 6, gap: 2, direction: "column", alignItems: "stretch", children: prohibitedFields.map(([fieldPath, reason]) => (0, import_jsx_runtime.jsxs)(
      Flex,
      {
        direction: "column",
        gap: 2,
        alignItems: "flex-start",
        borderColor: "neutral200",
        hasRadius: true,
        padding: 6,
        children: [
          (0, import_jsx_runtime.jsx)(Flex, { direction: "row", tag: "ol", children: fieldPath.map((pathSegment, index2) => (0, import_jsx_runtime.jsxs)(Typography, { fontWeight: "semiBold", tag: "li", children: [
            pathSegment,
            index2 !== fieldPath.length - 1 && (0, import_jsx_runtime.jsx)(
              ForwardRef$4p,
              {
                fill: "neutral500",
                height: "0.8rem",
                width: "0.8rem",
                style: { margin: "0 0.8rem" }
              }
            )
          ] }, index2)) }),
          (0, import_jsx_runtime.jsx)(Typography, { tag: "p", textColor: "neutral600", children: formatMessage3({
            id: getTranslation(`containers.list.autoCloneModal.error.${reason}`),
            defaultMessage: getDefaultErrorMessage(reason)
          }) })
        ]
      },
      fieldPath.join()
    )) })
  ] });
};
var TableActions = ({ document }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const { model, collectionType } = useDoc();
  const plugins = useStrapiApp("TableActions", (state) => state.plugins);
  const props = {
    activeTab: null,
    model,
    documentId: document.documentId,
    collectionType,
    document
  };
  return (0, import_jsx_runtime.jsx)(
    DescriptionComponentRenderer,
    {
      props,
      descriptions: plugins["content-manager"].apis.getDocumentActions("table-row").filter((action) => action.name !== "PublishAction"),
      children: (actions2) => {
        const tableRowActions = actions2.filter((action) => {
          const positions = Array.isArray(action.position) ? action.position : [action.position];
          return positions.includes("table-row");
        });
        return (0, import_jsx_runtime.jsx)(
          DocumentActionsMenu,
          {
            actions: tableRowActions,
            label: formatMessage3({
              id: "content-manager.containers.list.table.row-actions",
              defaultMessage: "Row action"
            }),
            variant: "ghost"
          }
        );
      }
    }
  );
};
var EditAction = ({ documentId }) => {
  const navigate = useNavigate();
  const { formatMessage: formatMessage3 } = useIntl();
  const { canRead } = useDocumentRBAC("EditAction", ({ canRead: canRead2 }) => ({ canRead: canRead2 }));
  const { toggleNotification } = useNotification();
  const [{ query }] = useQueryParams();
  return {
    disabled: !canRead,
    icon: (0, import_jsx_runtime.jsx)(StyledPencil, {}),
    label: formatMessage3({
      id: "content-manager.actions.edit.label",
      defaultMessage: "Edit"
    }),
    position: "table-row",
    onClick: async () => {
      if (!documentId) {
        console.error(
          "You're trying to edit a document without an id, this is likely a bug with Strapi. Please open an issue."
        );
        toggleNotification({
          message: formatMessage3({
            id: "content-manager.actions.edit.error",
            defaultMessage: "An error occurred while trying to edit the document."
          }),
          type: "danger"
        });
        return;
      }
      navigate({
        pathname: documentId,
        search: (0, import_qs.stringify)({
          plugins: query.plugins
        })
      });
    }
  };
};
EditAction.type = "edit";
EditAction.position = "table-row";
var StyledPencil = dt(ForwardRef$1r)`
  path {
    fill: currentColor;
  }
`;
var CloneAction = ({ model, documentId }) => {
  const navigate = useNavigate();
  const { formatMessage: formatMessage3 } = useIntl();
  const { canCreate } = useDocumentRBAC("CloneAction", ({ canCreate: canCreate2 }) => ({ canCreate: canCreate2 }));
  const { toggleNotification } = useNotification();
  const { autoClone } = useDocumentActions();
  const [prohibitedFields, setProhibitedFields] = React11.useState([]);
  return {
    disabled: !canCreate,
    icon: (0, import_jsx_runtime.jsx)(StyledDuplicate, {}),
    label: formatMessage3({
      id: "content-manager.actions.clone.label",
      defaultMessage: "Duplicate"
    }),
    position: "table-row",
    onClick: async () => {
      if (!documentId) {
        console.error(
          "You're trying to clone a document in the table without an id, this is likely a bug with Strapi. Please open an issue."
        );
        toggleNotification({
          message: formatMessage3({
            id: "content-manager.actions.clone.error",
            defaultMessage: "An error occurred while trying to clone the document."
          }),
          type: "danger"
        });
        return;
      }
      const res = await autoClone({ model, sourceId: documentId });
      if ("data" in res) {
        navigate(res.data.documentId);
        return true;
      }
      if (isBaseQueryError(res.error) && res.error.details && typeof res.error.details === "object" && "prohibitedFields" in res.error.details && Array.isArray(res.error.details.prohibitedFields)) {
        const prohibitedFields2 = res.error.details.prohibitedFields;
        setProhibitedFields(prohibitedFields2);
      }
    },
    dialog: {
      type: "modal",
      title: formatMessage3({
        id: "content-manager.containers.list.autoCloneModal.header",
        defaultMessage: "Duplicate"
      }),
      content: (0, import_jsx_runtime.jsx)(AutoCloneFailureModalBody, { prohibitedFields }),
      footer: ({ onClose }) => {
        return (0, import_jsx_runtime.jsxs)(Modal.Footer, { children: [
          (0, import_jsx_runtime.jsx)(Button, { onClick: onClose, variant: "tertiary", children: formatMessage3({
            id: "cancel",
            defaultMessage: "Cancel"
          }) }),
          (0, import_jsx_runtime.jsx)(
            LinkButton,
            {
              tag: NavLink,
              to: {
                pathname: `clone/${documentId}`
              },
              children: formatMessage3({
                id: "content-manager.containers.list.autoCloneModal.create",
                defaultMessage: "Create"
              })
            }
          )
        ] });
      }
    }
  };
};
CloneAction.type = "clone";
CloneAction.position = "table-row";
var StyledDuplicate = dt(ForwardRef$3L)`
  path {
    fill: currentColor;
  }
`;
var DEFAULT_TABLE_ROW_ACTIONS = [EditAction, CloneAction];
var ContentManagerPlugin = class {
  constructor() {
    /**
     * The following properties are the stored ones provided by any plugins registering with
     * the content-manager. The function calls however, need to be called at runtime in the
     * application, so instead we collate them and run them later with the complete list incl.
     * ones already registered & the context of the view.
     */
    __publicField(this, "bulkActions", [...DEFAULT_BULK_ACTIONS]);
    __publicField(this, "documentActions", [
      ...DEFAULT_ACTIONS,
      ...DEFAULT_TABLE_ROW_ACTIONS,
      ...DEFAULT_HEADER_ACTIONS
    ]);
    __publicField(this, "editViewSidePanels", [ActionsPanel]);
    __publicField(this, "headerActions", []);
  }
  addEditViewSidePanel(panels) {
    if (Array.isArray(panels)) {
      this.editViewSidePanels = [...this.editViewSidePanels, ...panels];
    } else if (typeof panels === "function") {
      this.editViewSidePanels = panels(this.editViewSidePanels);
    } else {
      throw new Error(
        `Expected the \`panels\` passed to \`addEditViewSidePanel\` to be an array or a function, but received ${getPrintableType(
          panels
        )}`
      );
    }
  }
  addDocumentAction(actions2) {
    if (Array.isArray(actions2)) {
      this.documentActions = [...this.documentActions, ...actions2];
    } else if (typeof actions2 === "function") {
      this.documentActions = actions2(this.documentActions);
    } else {
      throw new Error(
        `Expected the \`actions\` passed to \`addDocumentAction\` to be an array or a function, but received ${getPrintableType(
          actions2
        )}`
      );
    }
  }
  addDocumentHeaderAction(actions2) {
    if (Array.isArray(actions2)) {
      this.headerActions = [...this.headerActions, ...actions2];
    } else if (typeof actions2 === "function") {
      this.headerActions = actions2(this.headerActions);
    } else {
      throw new Error(
        `Expected the \`actions\` passed to \`addDocumentHeaderAction\` to be an array or a function, but received ${getPrintableType(
          actions2
        )}`
      );
    }
  }
  addBulkAction(actions2) {
    if (Array.isArray(actions2)) {
      this.bulkActions = [...this.bulkActions, ...actions2];
    } else if (typeof actions2 === "function") {
      this.bulkActions = actions2(this.bulkActions);
    } else {
      throw new Error(
        `Expected the \`actions\` passed to \`addBulkAction\` to be an array or a function, but received ${getPrintableType(
          actions2
        )}`
      );
    }
  }
  get config() {
    return {
      id: PLUGIN_ID,
      name: "Content Manager",
      injectionZones: INJECTION_ZONES,
      apis: {
        addBulkAction: this.addBulkAction.bind(this),
        addDocumentAction: this.addDocumentAction.bind(this),
        addDocumentHeaderAction: this.addDocumentHeaderAction.bind(this),
        addEditViewSidePanel: this.addEditViewSidePanel.bind(this),
        getBulkActions: () => this.bulkActions,
        getDocumentActions: (position) => {
          if (position) {
            return this.documentActions.filter(
              (action) => action.position == void 0 || [action.position].flat().includes(position)
            );
          }
          return this.documentActions;
        },
        getEditViewSidePanels: () => this.editViewSidePanels,
        getHeaderActions: () => this.headerActions
      }
    };
  }
};
var getPrintableType = (value) => {
  const nativeType = typeof value;
  if (nativeType === "object") {
    if (value === null)
      return "null";
    if (Array.isArray(value))
      return "array";
    if (value instanceof Object && value.constructor.name !== "Object") {
      return value.constructor.name;
    }
  }
  return nativeType;
};
var HistoryAction = ({ model, document }) => {
  const { formatMessage: formatMessage3 } = useIntl();
  const [{ query }] = useQueryParams();
  const navigate = useNavigate();
  const { trackUsage } = useTracking();
  const { pathname } = useLocation();
  const pluginsQueryParams = (0, import_qs.stringify)({ plugins: query.plugins }, { encode: false });
  if (!window.strapi.features.isEnabled("cms-content-history")) {
    return null;
  }
  const handleOnClick = () => {
    const destination = { pathname: "history", search: pluginsQueryParams };
    trackUsage("willNavigate", {
      from: pathname,
      to: `${pathname}/${destination.pathname}`
    });
    navigate(destination);
  };
  return {
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$4j, {}),
    label: formatMessage3({
      id: "content-manager.history.document-action",
      defaultMessage: "Content History"
    }),
    onClick: handleOnClick,
    disabled: (
      /**
       * The user is creating a new document.
       * It hasn't been saved yet, so there's no history to go to
       */
      !document || /**
      * The document has been created but the current dimension has never been saved.
      * For example, the user is creating a new locale in an existing document,
      * so there's no history for the document in that locale
      */
      !document.id || /**
      * History is only available for content types created by the user.
      * These have the `api::` prefix, as opposed to the ones created by Strapi or plugins,
      * which start with `admin::` or `plugin::`
      */
      !model.startsWith("api::")
    ),
    position: "header"
  };
};
HistoryAction.type = "history";
HistoryAction.position = "header";
var historyAdmin = {
  bootstrap(app) {
    const { addDocumentAction } = app.getPlugin("content-manager").apis;
    addDocumentAction((actions2) => {
      const indexOfDeleteAction = actions2.findIndex((action) => action.type === "delete");
      actions2.splice(indexOfDeleteAction, 0, HistoryAction);
      return actions2;
    });
  }
};
var initialState = {
  collectionTypeLinks: [],
  components: [],
  fieldSizes: {},
  models: [],
  singleTypeLinks: [],
  isLoading: true
};
var appSlice = createSlice({
  name: "app",
  initialState,
  reducers: {
    setInitialData(state, action) {
      const {
        authorizedCollectionTypeLinks,
        authorizedSingleTypeLinks,
        components,
        contentTypeSchemas,
        fieldSizes
      } = action.payload;
      state.collectionTypeLinks = authorizedCollectionTypeLinks.filter(
        ({ isDisplayed }) => isDisplayed
      );
      state.singleTypeLinks = authorizedSingleTypeLinks.filter(({ isDisplayed }) => isDisplayed);
      state.components = components;
      state.models = contentTypeSchemas;
      state.fieldSizes = fieldSizes;
      state.isLoading = false;
    }
  }
});
var { actions, reducer: reducer$1 } = appSlice;
var { setInitialData } = actions;
var reducer = combineReducers({
  app: reducer$1
});
var previewApi = contentManagerApi.injectEndpoints({
  endpoints: (builder) => ({
    getPreviewUrl: builder.query({
      query({ query, params }) {
        return {
          url: `/content-manager/preview/url/${params.contentType}`,
          method: "GET",
          config: {
            params: query
          }
        };
      }
    })
  })
});
var { useGetPreviewUrlQuery } = previewApi;
var ConditionalTooltip = ({ isShown, label, children }) => {
  if (isShown) {
    return (0, import_jsx_runtime.jsx)(TooltipImpl, { label, children });
  }
  return children;
};
var PreviewSidePanel = ({ model, documentId, document }) => {
  var _a;
  const { formatMessage: formatMessage3 } = useIntl();
  const { trackUsage } = useTracking();
  const { pathname } = useLocation();
  const [{ query }] = useQueryParams();
  const isModified = useForm("PreviewSidePanel", (state) => state.modified);
  const { data, error } = useGetPreviewUrlQuery({
    params: {
      contentType: model
    },
    query: {
      documentId,
      locale: document == null ? void 0 : document.locale,
      status: document == null ? void 0 : document.status
    }
  });
  if (!((_a = data == null ? void 0 : data.data) == null ? void 0 : _a.url) || error) {
    return null;
  }
  const trackNavigation = () => {
    const destinationPathname = pathname.replace(/\/$/, "") + "/preview";
    trackUsage("willNavigate", { from: pathname, to: destinationPathname });
  };
  return {
    title: formatMessage3({ id: "content-manager.preview.panel.title", defaultMessage: "Preview" }),
    content: (0, import_jsx_runtime.jsx)(
      ConditionalTooltip,
      {
        label: formatMessage3({
          id: "content-manager.preview.panel.button-disabled-tooltip",
          defaultMessage: "Please save to open the preview"
        }),
        isShown: isModified,
        children: (0, import_jsx_runtime.jsx)(Box, { cursor: "not-allowed", width: "100%", children: (0, import_jsx_runtime.jsx)(
          Button,
          {
            variant: "tertiary",
            tag: Link,
            to: { pathname: "preview", search: (0, import_qs.stringify)(query, { encode: false }) },
            onClick: trackNavigation,
            width: "100%",
            disabled: isModified,
            pointerEvents: isModified ? "none" : void 0,
            tabIndex: isModified ? -1 : void 0,
            children: formatMessage3({
              id: "content-manager.preview.panel.button",
              defaultMessage: "Open preview"
            })
          }
        ) })
      }
    )
  };
};
var previewAdmin = {
  bootstrap(app) {
    const contentManagerPluginApis = app.getPlugin("content-manager").apis;
    contentManagerPluginApis.addEditViewSidePanel([PreviewSidePanel]);
  }
};
var index = {
  register(app) {
    const cm = new ContentManagerPlugin();
    app.addReducers({
      [PLUGIN_ID]: reducer
    });
    app.addMenuLink({
      to: PLUGIN_ID,
      icon: ForwardRef$3r,
      intlLabel: {
        id: `content-manager.plugin.name`,
        defaultMessage: "Content Manager"
      },
      permissions: [],
      position: 1
    });
    app.router.addRoute({
      path: "content-manager/*",
      lazy: async () => {
        const { Layout } = await import("./layout-fQk1rMk9-F7VODUSE.js");
        return {
          Component: Layout
        };
      },
      children: routes
    });
    app.registerPlugin(cm.config);
  },
  bootstrap(app) {
    if (typeof historyAdmin.bootstrap === "function") {
      historyAdmin.bootstrap(app);
    }
    if (typeof previewAdmin.bootstrap === "function") {
      previewAdmin.bootstrap(app);
    }
  },
  async registerTrads({ locales }) {
    const importedTrads = await Promise.all(
      locales.map((locale) => {
        return __variableDynamicImportRuntimeHelper(Object.assign({ "./translations/ar.json": () => import("./ar-CCEVvqGG-2LPKV63P.js"), "./translations/ca.json": () => import("./ca-5U32ON2v-X35OBVUA.js"), "./translations/cs.json": () => import("./cs-CM2aBUar-FDAE3D6L.js"), "./translations/de.json": () => import("./de-C72KDNOl-SPR74ENO.js"), "./translations/en.json": () => import("./en-D65uIF6Y-Q2R2XTGH.js"), "./translations/es.json": () => import("./es-D34tqjMw-TO2PRADW.js"), "./translations/eu.json": () => import("./eu-CdALomew-DCWNNLD3.js"), "./translations/fr.json": () => import("./fr-DBseuRuB-ACQEXRKR.js"), "./translations/gu.json": () => import("./gu-CNpaMDpH-65GU634W.js"), "./translations/hi.json": () => import("./hi-Dwvd04m3-GRB2J3YE.js"), "./translations/hu.json": () => import("./hu-CeYvaaO0-XZA6LW5D.js"), "./translations/id.json": () => import("./id-BtwA9WJT-DRRWJOS5.js"), "./translations/it.json": () => import("./it-BrVPqaf1-JUBWS4GJ.js"), "./translations/ja.json": () => import("./ja-BHqhDq4V-X2OWWJB7.js"), "./translations/ko.json": () => import("./ko-HVQRlfUI-5BFZB35C.js"), "./translations/ml.json": () => import("./ml-BihZwQit-QVGU6WGE.js"), "./translations/ms.json": () => import("./ms-m_WjyWx7-5MBOMHBO.js"), "./translations/nl.json": () => import("./nl-D4R9gHx5-JDRK3CFV.js"), "./translations/pl.json": () => import("./pl-sbx9mSt_-O422ALCO.js"), "./translations/pt-BR.json": () => import("./pt-BR-C71iDxnh-XQSFVKJX.js"), "./translations/pt.json": () => import("./pt-BsaFvS8--XAR2T4VK.js"), "./translations/ru.json": () => import("./ru-BE6A4Exp-DCJPHHOO.js"), "./translations/sa.json": () => import("./sa-Dag0k-Z8-PI45V6SX.js"), "./translations/sk.json": () => import("./sk-BFg-R8qJ-7SJCIJGJ.js"), "./translations/sv.json": () => import("./sv-CUnfWGsh-SO3ZDGTD.js"), "./translations/th.json": () => import("./th-BqbI8lIT-72RFTSCT.js"), "./translations/tr.json": () => import("./tr-CgeK3wJM-YOCPB2XR.js"), "./translations/uk.json": () => import("./uk-CR-zDhAY-RWME4NHY.js"), "./translations/vi.json": () => import("./vi-DUXIk_fw-ID53NLDC.js"), "./translations/zh-Hans.json": () => import("./zh-Hans-BPQcRIyH-272ROKUV.js"), "./translations/zh.json": () => import("./zh-BWZspA60-CK67RPTV.js") }), `./translations/${locale}.json`, 3).then(({ default: data }) => {
          return {
            data: prefixPluginTranslations(data, PLUGIN_ID),
            locale
          };
        }).catch(() => {
          return {
            data: {},
            locale
          };
        });
      })
    );
    return Promise.resolve(importedTrads);
  }
};

export {
  useIntl,
  PERMISSIONS,
  InjectionZone,
  CREATOR_FIELDS,
  ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD,
  SINGLE_TYPES,
  COLLECTION_TYPES,
  useDocumentRBAC,
  DocumentRBAC,
  prepareTempKeys,
  removeFieldsThatDontExistOnSchema,
  transformDocument,
  createDefaultForm,
  contentManagerApi,
  useGetAllDocumentsQuery,
  buildValidParams,
  createYupSchema,
  useGetInitialDataQuery,
  useContentTypeSchema,
  extractContentTypeComponents,
  HOOKS,
  useGetContentTypeConfigurationQuery,
  useGetAllContentTypeSettingsQuery,
  useUpdateContentTypeConfigurationMutation,
  checkIfAttributeIsDisplayable,
  getMainField,
  DEFAULT_SETTINGS,
  useDocumentLayout,
  useDocLayout,
  convertEditLayoutToFieldLayouts,
  convertListLayoutToFieldLayouts,
  useDocument,
  useDoc,
  useContentManagerContext,
  getTranslation,
  useDocumentActions,
  CLONE_PATH,
  RelativeTime,
  getDisplayName,
  capitalise,
  DocumentStatus,
  Header,
  Panels,
  BulkActionsRenderer,
  TableActions,
  setInitialData,
  useGetPreviewUrlQuery,
  index
};
//# sourceMappingURL=chunk-W5YB4I3Z.js.map
